import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors()
            .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .csrf().disable()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasAuthority("Admin")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(new CustomJwtAuthenticationConverter())
                )
            );
        return http.build();
    }
}



Create JWT Authentication Converter

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class CustomJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {

    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
        return new JwtAuthenticationToken(jwt, authorities);
    }

    private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
        // Extract roles from Okta JWT claims
        Map<String, Object> claims = jwt.getClaims();
        
        // Check for groups claim (common in Okta)
        if (claims.containsKey("groups")) {
            List<String> groups = (List<String>) claims.get("groups");
            return groups.stream()
                    .map(group -> new SimpleGrantedAuthority("ROLE_" + group))
                    .collect(Collectors.toList());
        }
        
        // Check for scopes claim
        if (claims.containsKey("scp")) {
            String scope = (String) claims.get("scp");
            return Collections.singletonList(new SimpleGrantedAuthority("SCOPE_" + scope));
        }
        
        return Collections.emptyList();
    }
}

Create a Controller with Protected Endpoints


import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class ApiController {

    @GetMapping("/public/hello")
    public String publicEndpoint() {
        return "Hello from public endpoint!";
    }

    @GetMapping("/protected/user")
    @PreAuthorize("isAuthenticated()")
    public String userEndpoint(@AuthenticationPrincipal Jwt jwt) {
        return "Hello user: " + jwt.getClaimAsString("preferred_username");
    }

    @GetMapping("/admin/dashboard")
    @PreAuthorize("hasAuthority('ROLE_Admin')")
    public String adminEndpoint() {
        return "Welcome to admin dashboard!";
    }

    @GetMapping("/profile")
    @PreAuthorize("isAuthenticated()")
    public Map<String, Object> getUserProfile(@AuthenticationPrincipal Jwt jwt) {
        return jwt.getClaims();
    }
}


Configure CORS for React Frontend


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
public class CorsConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "X-Requested-With"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


react
======

npm install @okta/okta-react @okta/okta-auth-js react-router-dom

Create Okta Configuration File

// src/oktaConfig.js
import { OktaAuth } from '@okta/okta-auth-js';

const oktaAuth = new OktaAuth({
  issuer: 'https://{your-okta-domain}.okta.com/oauth2/default',
  clientId: '{your-client-id}',
  redirectUri: window.location.origin + '/login/callback',
  scopes: ['openid', 'profile', 'email'],
});

export default oktaAuth;

Update Main App Component

// src/App.js
import React from 'react';
import { Route, useHistory, Switch } from 'react-router-dom';
import { Security, SecureRoute, LoginCallback } from '@okta/okta-react';
import { OktaAuth, toRelativeUrl } from '@okta/okta-auth-js';
import oktaAuth from './oktaConfig';
import Home from './components/Home';
import Profile from './components/Profile';
import Admin from './components/Admin';
import Login from './components/Login';
import Header from './components/Header';

function App() {
  const history = useHistory();

  const restoreOriginalUri = async (_oktaAuth, originalUri) => {
    history.replace(toRelativeUrl(originalUri || '/', window.location.origin));
  };

  const customAuthHandler = () => {
    history.push('/login');
  };

  return (
    <Security
      oktaAuth={oktaAuth}
      restoreOriginalUri={restoreOriginalUri}
      onAuthRequired={customAuthHandler}
    >
      <Header />
      <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/login" component={Login} />
        <Route path="/login/callback" component={LoginCallback} />
        <SecureRoute path="/profile" component={Profile} />
        <SecureRoute path="/admin" component={Admin} />
      </Switch>
    </Security>
  );
}

export default App;

Create React Components

// src/components/Header.js
import React from 'react';
import { useOktaAuth } from '@okta/okta-react';
import { Link } from 'react-router-dom';

const Header = () => {
  const { oktaAuth, authState } = useOktaAuth();

  const login = async () => oktaAuth.signInWithRedirect();
  const logout = async () => oktaAuth.signOut();

  return (
    <header style={{ padding: '1rem', background: '#f0f0f0' }}>
      <nav>
        <Link to="/">Home</Link> | 
        <Link to="/profile">Profile</Link> | 
        <Link to="/admin">Admin</Link>
      </nav>
      {!authState || !authState.isAuthenticated ? (
        <button onClick={login}>Login</button>
      ) : (
        <button onClick={logout}>Logout</button>
      )}
    </header>
  );
};

export default Header;

// src/components/Home.js
import React from 'react';

const Home = () => {
  return (
    <div>
      <h1>Welcome to the Application</h1>
      <p>This is the public home page.</p>
    </div>
  );
};

export default Home;


// src/components/Login.js
import React from 'react';
import { useOktaAuth } from '@okta/okta-react';

const Login = () => {
  const { oktaAuth } = useOktaAuth();

  const login = async () => {
    oktaAuth.signInWithRedirect();
  };

  return (
    <div style={{ textAlign: 'center', marginTop: '2rem' }}>
      <h2>Login Required</h2>
      <button onClick={login} style={{ padding: '10px 20px', fontSize: '16px' }}>
        Login with Okta
      </button>
    </div>
  );
};

export default Login;

// src/components/Profile.js
import React, { useState, useEffect } from 'react';
import { useOktaAuth } from '@okta/okta-react';

const Profile = () => {
  const { authState, oktaAuth } = useOktaAuth();
  const [userInfo, setUserInfo] = useState(null);
  const [apiData, setApiData] = useState('');

  useEffect(() => {
    if (!authState || !authState.isAuthenticated) {
      setUserInfo(null);
    } else {
      oktaAuth.getUser().then(info => {
        setUserInfo(info);
      });
    }
  }, [authState, oktaAuth]);

  const callProtectedApi = async () => {
    try {
      const token = oktaAuth.getAccessToken();
      const response = await fetch('http://localhost:8080/api/protected/user', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.text();
      setApiData(data);
    } catch (error) {
      console.error('Error calling API:', error);
      setApiData('Error calling API');
    }
  };

  if (!userInfo) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>User Profile</h1>
      <div>
        <p><strong>Name:</strong> {userInfo.name}</p>
        <p><strong>Email:</strong> {userInfo.email}</p>
        <p><strong>Username:</strong> {userInfo.preferred_username}</p>
      </div>
      <button onClick={callProtectedApi} style={{ marginTop: '1rem' }}>
        Call Protected API
      </button>
      {apiData && (
        <div style={{ marginTop: '1rem', padding: '1rem', background: '#e0e0e0' }}>
          <strong>API Response:</strong> {apiData}
        </div>
      )}
    </div>
  );
};

export default Profile;


// src/components/Admin.js
import React, { useState } from 'react';
import { useOktaAuth } from '@okta/okta-react';

const Admin = () => {
  const { oktaAuth } = useOktaAuth();
  const [apiData, setApiData] = useState('');

  const callAdminApi = async () => {
    try {
      const token = oktaAuth.getAccessToken();
      const response = await fetch('http://localhost:8080/api/admin/dashboard', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      
      if (response.ok) {
        const data = await response.text();
        setApiData(data);
      } else {
        setApiData(`Error: ${response.status} - ${response.statusText}`);
      }
    } catch (error) {
      console.error('Error calling admin API:', error);
      setApiData('Error calling admin API');
    }
  };

  return (
    <div>
      <h1>Admin Dashboard</h1>
      <button onClick={callAdminApi} style={{ marginTop: '1rem' }}>
        Call Admin API
      </button>
      {apiData && (
        <div style={{ marginTop: '1rem', padding: '1rem', background: '#e0e0e0' }}>
          <strong>API Response:</strong> {apiData}
        </div>
      )}
    </div>
  );
};

export default Admin;


// src/services/api.js
import { useOktaAuth } from '@okta/okta-react';

class ApiService {
  constructor() {
    this.baseURL = 'http://localhost:8080/api';
  }

  async getAuthHeaders(oktaAuth) {
    const token = await oktaAuth.getAccessToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  async get(oktaAuth, endpoint) {
    const headers = await this.getAuthHeaders(oktaAuth);
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'GET',
      headers,
    });
    return this.handleResponse(response);
  }

  async post(oktaAuth, endpoint, data) {
    const headers = await this.getAuthHeaders(oktaAuth);
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  async handleResponse(response) {
    if (response.ok) {
      return response.json();
    } else {
      throw new Error(`API error: ${response.status}`);
    }
  }
}

export default new ApiService();
