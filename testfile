src/services/websocketService.js
---------------------------------
class WebSocketService {
  constructor() {
    this.socket = null;
    this.messageHandlers = new Set();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectInterval = 3000;
  }

  connect(executionId, token) {
    if (this.socket) {
      this.disconnect();
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/execution/${executionId}?token=${token}`;
    
    this.socket = new WebSocket(wsUrl);
    
    this.socket.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.notifyHandlers({ type: 'connected', data: {} });
    };

    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.notifyHandlers(data);
      } catch (error) {
        console.error('Error parsing WebSocket message:', error);
        this.notifyHandlers({ 
          type: 'raw_output', 
          data: { output: event.data } 
        });
      }
    };

    this.socket.onclose = (event) => {
      console.log('WebSocket disconnected:', event.code, event.reason);
      this.notifyHandlers({ 
        type: 'disconnected', 
        data: { code: event.code, reason: event.reason } 
      });
      
      if (event.code !== 1000) { // Don't reconnect on normal closure
        this.attemptReconnect(executionId, token);
      }
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.notifyHandlers({ type: 'error', data: { error: error.message } });
    };
  }

  attemptReconnect(executionId, token) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        console.log(`Attempting reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
        this.connect(executionId, token);
      }, this.reconnectInterval * this.reconnectAttempts);
    }
  }

  addMessageHandler(handler) {
    this.messageHandlers.add(handler);
  }

  removeMessageHandler(handler) {
    this.messageHandlers.delete(handler);
  }

  notifyHandlers(message) {
    this.messageHandlers.forEach(handler => {
      try {
        handler(message);
      } catch (error) {
        console.error('Error in message handler:', error);
      }
    });
  }

  send(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(typeof message === 'string' ? message : JSON.stringify(message));
    }
  }

  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
    this.messageHandlers.clear();
  }

  getStatus() {
    if (!this.socket) return 'disconnected';
    switch (this.socket.readyState) {
      case WebSocket.CONNECTING: return 'connecting';
      case WebSocket.OPEN: return 'connected';
      case WebSocket.CLOSING: return 'closing';
      case WebSocket.CLOSED: return 'disconnected';
      default: return 'unknown';
    }
  }
}

export const websocketService = new WebSocketService();


src/services/ansibleApi.js
--------------------------
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || '/api';
const API_TOKEN = process.env.REACT_APP_API_TOKEN || 'dev-token-default-change-in-production';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add token to all requests
api.interceptors.request.use((config) => {
  config.headers['x-token'] = API_TOKEN;
  return config;
});

export const ansibleApi = {
  // Get available environments
  getEnvironments: () => api.get('/commands/environments'),
  
  // Get available roles
  getRoles: () => api.get('/commands/roles'),
  
  // Execute command
  executeCommand: (command, environment, role, timeout = 300) => 
    api.post('/commands/execute', { command, environment, role, timeout }),
  
  // Get execution status
  getExecutionStatus: (executionId) => 
    api.get(`/execution/${executionId}/status`),
};

export default api;

src/components/AnsibleCommand/AnsibleCommand.jsx
------------------------------------------------
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Card,
  CardContent,
  LinearProgress,
  Chip,
  Alert,
  IconButton,
  CircularProgress
} from '@mui/material';
import {
  PlayArrow as PlayArrowIcon,
  Stop as StopIcon,
  Clear as ClearIcon
} from '@mui/icons-material';
import { ansibleApi } from '../../services/ansibleApi';
import { websocketService } from '../../services/websocketService';
import TerminalOutput from './TerminalOutput';
import './AnsibleCommand.css';

const AnsibleCommand = () => {
  const [environments, setEnvironments] = useState([]);
  const [roles, setRoles] = useState([]);
  const [selectedEnv, setSelectedEnv] = useState('');
  const [selectedRole, setSelectedRole] = useState('');
  const [command, setCommand] = useState('');
  const [isExecuting, setIsExecuting] = useState(false);
  const [executionId, setExecutionId] = useState(null);
  const [output, setOutput] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [hosts, setHosts] = useState([]);
  const [progress, setProgress] = useState(0);

  const outputEndRef = useRef(null);

  useEffect(() => {
    loadData();
    return () => {
      websocketService.disconnect();
    };
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [output]);

  const loadData = async () => {
    try {
      const [envResponse, rolesResponse] = await Promise.all([
        ansibleApi.getEnvironments(),
        ansibleApi.getRoles()
      ]);
      setEnvironments(envResponse.data);
      setRoles(rolesResponse.data);
    } catch (err) {
      setError('Failed to load environments and roles');
    }
  };

  const scrollToBottom = () => {
    outputEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const handleWebSocketMessage = (message) => {
    switch (message.type) {
      case 'host_result':
        setOutput(prev => [...prev, {
          type: 'host_result',
          host: message.data.host,
          status: message.data.status,
          output: message.data.output,
          timestamp: new Date().toLocaleTimeString()
        }]);
        break;

      case 'raw_output':
        setOutput(prev => [...prev, {
          type: 'raw_output',
          output: message.data.output,
          timestamp: new Date().toLocaleTimeString()
        }]);
        break;

      case 'start':
        setOutput(prev => [...prev, {
          type: 'info',
          output: `Execution started: ${message.data.command} on ${message.data.environment} ${message.data.role}`,
          timestamp: new Date().toLocaleTimeString()
        }]);
        break;

      case 'complete':
        setOutput(prev => [...prev, {
          type: 'success',
          output: 'Execution completed successfully',
          timestamp: new Date().toLocaleTimeString()
        }]);
        setIsExecuting(false);
        setConnectionStatus('disconnected');
        break;

      case 'error':
        setOutput(prev => [...prev, {
          type: 'error',
          output: `Error: ${message.data.message}`,
          timestamp: new Date().toLocaleTimeString()
        }]);
        setIsExecuting(false);
        setConnectionStatus('disconnected');
        setError(message.data.message);
        break;

      case 'connected':
        setConnectionStatus('connected');
        break;

      case 'disconnected':
        setConnectionStatus('disconnected');
        if (isExecuting) {
          setOutput(prev => [...prev, {
            type: 'warning',
            output: 'WebSocket disconnected',
            timestamp: new Date().toLocaleTimeString()
          }]);
        }
        break;

      default:
        console.log('Unknown message type:', message.type);
    }
  };

  const executeCommand = async () => {
    if (!command.trim() || !selectedEnv || !selectedRole) {
      setError('Please select environment, role, and enter a command');
      return;
    }

    setIsExecuting(true);
    setError('');
    setSuccess('');
    setOutput([]);
    setProgress(0);

    try {
      const response = await ansibleApi.executeCommand(command, selectedEnv, selectedRole);
      const execId = response.data.execution_id;
      setExecutionId(execId);
      setSuccess('Command execution started');

      // Connect to WebSocket for real-time updates
      websocketService.addMessageHandler(handleWebSocketMessage);
      websocketService.connect(execId, process.env.REACT_APP_API_TOKEN);

    } catch (err) {
      setIsExecuting(false);
      setError(err.response?.data?.detail || 'Failed to execute command');
    }
  };

  const stopExecution = () => {
    websocketService.disconnect();
    setIsExecuting(false);
    setOutput(prev => [...prev, {
      type: 'info',
      output: 'Execution stopped by user',
      timestamp: new Date().toLocaleTimeString()
    }]);
  };

  const clearOutput = () => {
    setOutput([]);
    setError('');
    setSuccess('');
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'connected': return 'success';
      case 'connecting': return 'warning';
      case 'disconnected': return 'error';
      default: return 'default';
    }
  };

  return (
    <Box className="ansible-command-container">
      <Typography variant="h4" gutterBottom>
        Ansible Command Execution
      </Typography>

      <Grid container spacing={3}>
        {/* Configuration Panel */}
        <Grid item xs={12} md={4}>
          <Paper className="config-panel" elevation={2}>
            <Typography variant="h6" gutterBottom>
              Configuration
            </Typography>

            <FormControl fullWidth margin="normal">
              <InputLabel>Environment</InputLabel>
              <Select
                value={selectedEnv}
                label="Environment"
                onChange={(e) => setSelectedEnv(e.target.value)}
                disabled={isExecuting}
              >
                <MenuItem value="">Select Environment</MenuItem>
                {environments.map(env => (
                  <MenuItem key={env} value={env}>
                    {env.toUpperCase()}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <FormControl fullWidth margin="normal">
              <InputLabel>Server Role</InputLabel>
              <Select
                value={selectedRole}
                label="Server Role"
                onChange={(e) => setSelectedRole(e.target.value)}
                disabled={isExecuting || !selectedEnv}
              >
                <MenuItem value="">Select Role</MenuItem>
                {roles.map(role => (
                  <MenuItem key={role} value={role}>
                    {role}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <TextField
              fullWidth
              margin="normal"
              label="Command to Execute"
              placeholder="Enter command (e.g., 'df -h', 'ps aux | grep java')"
              value={command}
              onChange={(e) => setCommand(e.target.value)}
              disabled={isExecuting}
              multiline
              rows={4}
              variant="outlined"
            />

            <Box className="action-buttons">
              <Button
                variant="contained"
                color="primary"
                startIcon={isExecuting ? <CircularProgress size={20} /> : <PlayArrowIcon />}
                onClick={executeCommand}
                disabled={isExecuting || !command || !selectedEnv || !selectedRole}
                fullWidth
              >
                {isExecuting ? 'Executing...' : 'Execute Command'}
              </Button>

              {isExecuting && (
                <Button
                  variant="outlined"
                  color="secondary"
                  startIcon={<StopIcon />}
                  onClick={stopExecution}
                  fullWidth
                  sx={{ mt: 1 }}
                >
                  Stop Execution
                </Button>
              )}
            </Box>

            {error && (
              <Alert severity="error" sx={{ mt: 2 }}>
                {error}
              </Alert>
            )}

            {success && (
              <Alert severity="success" sx={{ mt: 2 }}>
                {success}
              </Alert>
            )}

            <Box className="status-info" sx={{ mt: 2 }}>
              <Chip
                label={`WebSocket: ${connectionStatus}`}
                color={getStatusColor(connectionStatus)}
                size="small"
              />
              {executionId && (
                <Typography variant="caption" display="block" sx={{ mt: 1 }}>
                  Execution ID: {executionId}
                </Typography>
              )}
            </Box>
          </Paper>
        </Grid>

        {/* Terminal Output */}
        <Grid item xs={12} md={8}>
          <Paper className="terminal-panel" elevation={2}>
            <Box className="terminal-header">
              <Typography variant="h6">Terminal Output</Typography>
              <IconButton onClick={clearOutput} size="small" disabled={output.length === 0}>
                <ClearIcon />
              </IconButton>
            </Box>

            {isExecuting && (
              <LinearProgress 
                variant="indeterminate" 
                sx={{ mb: 1 }} 
              />
            )}

            <TerminalOutput output={output} />

            <div ref={outputEndRef} />
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default AnsibleCommand;

src/components/AnsibleCommand/TerminalOutput.jsx
--------------------------------------------------
import React from 'react';
import { Box, Typography } from '@mui/material';

const TerminalOutput = ({ output }) => {
  const getOutputStyle = (type) => {
    switch (type) {
      case 'error':
        return { color: '#f44336', backgroundColor: '#ffebee', padding: '2px 4px', borderRadius: '2px' };
      case 'success':
        return { color: '#4caf50', backgroundColor: '#e8f5e8', padding: '2px 4px', borderRadius: '2px' };
      case 'warning':
        return { color: '#ff9800', backgroundColor: '#fff3e0', padding: '2px 4px', borderRadius: '2px' };
      case 'info':
        return { color: '#2196f3', backgroundColor: '#e3f2fd', padding: '2px 4px', borderRadius: '2px' };
      case 'host_result':
        return { color: '#333', fontFamily: 'monospace' };
      default:
        return { color: '#333', fontFamily: 'monospace' };
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'SUCCESS': return '✅';
      case 'CHANGED': return '🔄';
      case 'FAILED': return '❌';
      case 'UNREACHABLE': return '🔌';
      default: return '📋';
    }
  };

  if (output.length === 0) {
    return (
      <Box className="terminal-empty">
        <Typography variant="body2" color="textSecondary">
          No output yet. Execute a command to see results here.
        </Typography>
      </Box>
    );
  }

  return (
    <Box className="terminal-output">
      {output.map((item, index) => (
        <Box key={index} className="terminal-line" sx={{ mb: 0.5 }}>
          <Typography variant="body2" component="pre" sx={{ fontFamily: 'monospace', fontSize: '12px', m: 0 }}>
            {/* Timestamp */}
            <span style={{ color: '#666', marginRight: '8px' }}>
              [{item.timestamp}]
            </span>

            {/* Host result with status icon */}
            {item.type === 'host_result' && (
              <>
                <span style={{ fontWeight: 'bold', marginRight: '8px' }}>
                  {item.host}
                </span>
                <span style={{ marginRight: '8px' }}>
                  {getStatusIcon(item.status)}
                </span>
                <span style={getOutputStyle(item.status.toLowerCase())}>
                  {item.status}
                </span>
                <span style={{ marginLeft: '8px' }}>
                  {item.output}
                </span>
              </>
            )}

            {/* Other message types */}
            {item.type !== 'host_result' && (
              <span style={getOutputStyle(item.type)}>
                {item.output}
              </span>
            )}
          </Typography>
        </Box>
      ))}
    </Box>
  );
};

export default TerminalOutput;

src/components/AnsibleCommand/AnsibleCommand.css
--------------------------------------------------

.ansible-command-container {
  padding: 20px;
  height: 100%;
}

.config-panel {
  padding: 20px;
  height: fit-content;
  position: sticky;
  top: 20px;
}

.terminal-panel {
  padding: 20px;
  height: 70vh;
  display: flex;
  flex-direction: column;
}

.terminal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.terminal-output {
  flex: 1;
  overflow-y: auto;
  background-color: #1e1e1e;
  color: #d4d4d4;
  padding: 15px;
  border-radius: 4px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 12px;
  line-height: 1.4;
}

.terminal-empty {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.terminal-line {
  margin-bottom: 4px;
  white-space: pre-wrap;
  word-break: break-all;
}

.action-buttons {
  margin-top: 20px;
}

.status-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* Scrollbar styling for terminal */
.terminal-output::-webkit-scrollbar {
  width: 8px;
}

.terminal-output::-webkit-scrollbar-track {
  background: #2d2d2d;
}

.terminal-output::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 4px;
}

.terminal-output::-webkit-scrollbar-thumb:hover {
  background: #777;
}

REACT_APP_API_URL=http://localhost:8000
REACT_APP_API_TOKEN=dev-token-default-change-in-production

npm install @mui/material @emotion/react @emotion/styled @mui/icons-material axios

