// SecurityConfig.java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.client.web.HttpSessionOAuth2AuthorizationRequestRepository;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestResolver;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtTokenFilter jwtTokenFilter;
    private final CustomOAuth2AuthorizationRequestResolver customAuthorizationRequestResolver;
    private final CustomOAuth2AuthorizationRequestRepository authorizationRequestRepository;

    public SecurityConfig(JwtTokenFilter jwtTokenFilter,
                         CustomOAuth2AuthorizationRequestResolver customAuthorizationRequestResolver,
                         CustomOAuth2AuthorizationRequestRepository authorizationRequestRepository) {
        this.jwtTokenFilter = jwtTokenFilter;
        this.customAuthorizationRequestResolver = customAuthorizationRequestResolver;
        this.authorizationRequestRepository = authorizationRequestRepository;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors().and()
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) // Changed to IF_REQUIRED
            .and()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**", "/login/**", "/oauth2/**", "/error").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .authorizationEndpoint(authorization -> authorization
                    .baseUri("/oauth2/authorization")
                    .authorizationRequestResolver(customAuthorizationRequestResolver)
                    .authorizationRequestRepository(authorizationRequestRepository)
                )
                .redirectionEndpoint(redirection -> redirection
                    .baseUri("/login/oauth2/code/*")
                )
                .successHandler((request, response, authentication) -> {
                    // Generate JWT token
                    String token = jwtTokenUtil.generateToken((UserDetails) authentication.getPrincipal());
                    response.sendRedirect("http://localhost:3000/login/callback?token=" + token);
                })
                .failureHandler((request, response, exception) -> {
                    response.sendRedirect("http://localhost:3000/login?error=auth_failed");
                })
            )
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}


// CustomOAuth2AuthorizationRequestRepository.java
import org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRepository;
import org.springframework.security.oauth2.core.endpoint.OAuth2AuthorizationRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.SerializationUtils;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import java.util.Base64;

@Component
public class CustomOAuth2AuthorizationRequestRepository implements OAuth2AuthorizationRequestRepository<OAuth2AuthorizationRequest> {

    private static final String DEFAULT_AUTHORIZATION_REQUEST_ATTR_NAME = 
        CustomOAuth2AuthorizationRequestRepository.class.getName() + ".AUTHORIZATION_REQUEST";

    @Override
    public OAuth2AuthorizationRequest loadAuthorizationRequest(HttpServletRequest request) {
        String state = request.getParameter("state");
        if (state != null) {
            return getAuthorizationRequest(request, state);
        }
        return null;
    }

    @Override
    public void saveAuthorizationRequest(OAuth2AuthorizationRequest authorizationRequest, 
                                       HttpServletRequest request, 
                                       HttpServletResponse response) {
        if (authorizationRequest == null) {
            removeAuthorizationRequest(request, response);
            return;
        }

        String state = authorizationRequest.getState();
        request.getSession().setAttribute(getSessionAttributeName(state), authorizationRequest);
    }

    @Override
    public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request, 
                                                                HttpServletResponse response) {
        String state = request.getParameter("state");
        if (state == null) {
            return null;
        }
        return removeAuthorizationRequest(request, response, state);
    }

    public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request, 
                                                                HttpServletResponse response, 
                                                                String state) {
        String sessionAttributeName = getSessionAttributeName(state);
        OAuth2AuthorizationRequest authorizationRequest = getAuthorizationRequest(request, state);
        if (authorizationRequest != null) {
            request.getSession().removeAttribute(sessionAttributeName);
        }
        return authorizationRequest;
    }

    private OAuth2AuthorizationRequest getAuthorizationRequest(HttpServletRequest request, String state) {
        String sessionAttributeName = getSessionAttributeName(state);
        Object attribute = request.getSession().getAttribute(sessionAttributeName);
        return attribute instanceof OAuth2AuthorizationRequest ? (OAuth2AuthorizationRequest) attribute : null;
    }

    private String getSessionAttributeName(String state) {
        return DEFAULT_AUTHORIZATION_REQUEST_ATTR_NAME + "." + state;
    }
}


// CustomOAuth2AuthorizationRequestResolver.java
import org.springframework.security.oauth2.client.registration.ClientRegistration;
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestResolver;
import org.springframework.security.oauth2.core.endpoint.OAuth2AuthorizationRequest;
import org.springframework.security.oauth2.core.endpoint.PkceParameterNames;
import org.springframework.stereotype.Component;
import org.springframework.web.util.UriComponentsBuilder;

import jakarta.servlet.http.HttpServletRequest;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

@Component
public class CustomOAuth2AuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver {

    private final ClientRegistrationRepository clientRegistrationRepository;
    private final CustomOAuth2AuthorizationRequestRepository authorizationRequestRepository;

    public CustomOAuth2AuthorizationRequestResolver(ClientRegistrationRepository clientRegistrationRepository,
                                                  CustomOAuth2AuthorizationRequestRepository authorizationRequestRepository) {
        this.clientRegistrationRepository = clientRegistrationRepository;
        this.authorizationRequestRepository = authorizationRequestRepository;
    }

    @Override
    public OAuth2AuthorizationRequest resolve(HttpServletRequest request) {
        String registrationId = this.resolveRegistrationId(request);
        if (registrationId == null) {
            return null;
        }
        return resolve(request, registrationId);
    }

    @Override
    public OAuth2AuthorizationRequest resolve(HttpServletRequest request, String registrationId) {
        ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId);
        if (clientRegistration == null) {
            return null;
        }

        // Generate PKCE parameters (even if not required, it's good practice)
        String codeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(codeVerifier);
        String state = generateState();

        // Store code verifier and state in session
        request.getSession().setAttribute("code_verifier_" + state, codeVerifier);
        request.getSession().setAttribute("oauth2_state", state);

        OAuth2AuthorizationRequest.Builder builder = OAuth2AuthorizationRequest.authorizationCode()
                .clientId(clientRegistration.getClientId())
                .authorizationUri(clientRegistration.getProviderDetails().getAuthorizationUri())
                .redirectUri("http://localhost:8080/login/oauth2/code/okta")
                .scopes(clientRegistration.getScopes())
                .state(state)
                .additionalParameters(params -> {
                    // Add PKCE parameters even if not required
                    params.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge);
                    params.put(PkceParameterNames.CODE_CHALLENGE_METHOD, "S256");
                });

        OAuth2AuthorizationRequest authorizationRequest = builder.build();
        
        // Save the authorization request
        authorizationRequestRepository.saveAuthorizationRequest(authorizationRequest, request, null);

        return authorizationRequest;
    }

    private String resolveRegistrationId(HttpServletRequest request) {
        String requestUri = request.getRequestURI();
        String baseUri = "/oauth2/authorization/";
        
        if (requestUri.startsWith(baseUri)) {
            return requestUri.substring(baseUri.length());
        }
        return null;
    }

    private String generateCodeVerifier() {
        byte[] codeVerifier = new byte[32];
        new java.security.SecureRandom().nextBytes(codeVerifier);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(codeVerifier);
    }

    private String generateCodeChallenge(String codeVerifier) {
        try {
            byte[] bytes = codeVerifier.getBytes(StandardCharsets.US_ASCII);
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
            messageDigest.update(bytes, 0, bytes.length);
            byte[] digest = messageDigest.digest();
            return Base64.getUrlEncoder().withoutPadding().encodeToString(digest);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("Failed to generate code challenge", e);
        }
    }

    private String generateState() {
        byte[] state = new byte[16];
        new java.security.SecureRandom().nextBytes(state);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(state);
    }
}

// CustomOAuth2SuccessHandler.java
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class CustomOAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    private final JwtTokenUtil jwtTokenUtil;

    public CustomOAuth2SuccessHandler(JwtTokenUtil jwtTokenUtil) {
        this.jwtTokenUtil = jwtTokenUtil;
        setDefaultTargetUrl("http://localhost:3000/login/callback");
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                      Authentication authentication) throws IOException, ServletException {
        
        OAuth2User oauth2User = (OAuth2User) authentication.getPrincipal();
        
        // Create UserDetails from OAuth2User
        UserDetails userDetails = createUserDetailsFromOAuth2User(oauth2User);
        
        // Generate JWT token
        String token = jwtTokenUtil.generateToken(userDetails);
        
        // Redirect to frontend with token
        getRedirectStrategy().sendRedirect(request, response, getDefaultTargetUrl() + "?token=" + token);
    }

    private UserDetails createUserDetailsFromOAuth2User(OAuth2User oauth2User) {
        String username = oauth2User.getAttribute("email");
        String name = oauth2User.getAttribute("name");
        
        return new User(username, "", oauth2User.getAuthorities());
    }
}

// AuthController.java - Add this method
@GetMapping("/login/oauth2/code/okta")
public void oauth2Callback(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // This endpoint is handled by Spring Security, but we can add logging
    System.out.println("OAuth2 callback received");
    response.sendRedirect("http://localhost:3000/login/callback");
}


# Okta OAuth2 Configuration
spring.security.oauth2.client.registration.okta.client-id={your-client-id}
spring.security.oauth2.client.registration.okta.client-secret={your-client-secret}
spring.security.oauth2.client.registration.okta.scope=openid,profile,email
spring.security.oauth2.client.registration.okta.redirect-uri=http://localhost:8080/login/oauth2/code/okta
spring.security.oauth2.client.registration.okta.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.okta.client-name=Okta

# Okta Provider Configuration
spring.security.oauth2.client.provider.okta.issuer-uri=https://integrator-6564.okta.com/oauth2/default
spring.security.oauth2.client.provider.okta.user-name-attribute=email

# Session configuration
server.servlet.session.timeout=1800
spring.session.timeout=30m

# CORS
cors.allowed-origins=http://localhost:3000
cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
cors.allowed-headers=Authorization,Content-Type,X-Requested-With
cors.allow-credentials=true


// src/components/LoginCallback.js
import React, { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import authService from '../services/authService';

const LoginCallback = ({ setIsAuthenticated }) => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  useEffect(() => {
    const handleCallback = async () => {
      try {
        const token = searchParams.get('token');
        const error = searchParams.get('error');
        
        if (error) {
          throw new Error(`Authentication failed: ${error}`);
        }

        if (token) {
          authService.setToken(token);
          setIsAuthenticated(true);
          navigate('/', { replace: true });
        } else {
          // If no token, try to get it from the backend
          const response = await fetch('http://localhost:8080/api/auth/user', {
            credentials: 'include' // Important for session cookies
          });
          
          if (response.ok) {
            const user = await response.json();
            if (user) {
              setIsAuthenticated(true);
              navigate('/', { replace: true });
              return;
            }
          }
          
          throw new Error('No authentication token received');
        }
      } catch (error) {
        console.error('Login callback error:', error);
        navigate('/login', { 
          replace: true,
          state: { error: error.message }
        });
      }
    };

    handleCallback();
  }, [navigate, searchParams, setIsAuthenticated]);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      height: '50vh',
      flexDirection: 'column'
    }}>
      <div style={{ fontSize: '1.5rem', marginBottom: '1rem' }}>
        Completing authentication...
      </div>
      <div style={{ color: '#666' }}>
        Please wait while we secure your session.
      </div>
    </div>
  );
};

export default LoginCallback;
