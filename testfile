ansible-api-wrapper/
├── app/
│   ├── main.py
│   ├── dependencies.py
│   ├── models.py
│   ├── services/
│   │   ├── ansible_service.py
│   │   └── websocket_manager.py
│   ├── routes/
│   │   ├── commands.py
│   │   ├── inventory.py
│   │   └── ws.py
│   └── config.py
├── scripts/
│   └── inventory_parser.py
├── requirements.txt
├── .env
└── README.md


requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
websockets==12.0
python-multipart==0.0.6
python-dotenv==1.0.0
aiofiles==23.2.1
jinja2==3.1.2
paramiko==3.3.1
asyncssh==2.13.2
redis==5.0.1
celery==5.3.4


app/config.py
--------------
import os
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()

class Settings:
    # API Settings
    API_TITLE = "Ansible API Wrapper"
    API_VERSION = "1.0.0"
    API_DESCRIPTION = "API wrapper for Ansible command execution"
    
    # Security
    API_TOKEN = os.getenv("API_TOKEN", "dev-token-default-change-in-production")
    ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000,http://localhost:5173").split(",")
    
    # Ansible Settings
    ANSIBLE_NODE_HOST = os.getenv("ANSIBLE_NODE_HOST", "ansible-node.example.com")
    ANSIBLE_NODE_USER = os.getenv("ANSIBLE_NODE_USER", "ansible-user")
    ANSIBLE_NODE_SSH_KEY_PATH = os.getenv("ANSIBLE_NODE_SSH_KEY_PATH", "~/.ssh/id_rsa")
    ANSIBLE_INVENTORY_BASE = os.getenv("ANSIBLE_INVENTORY_BASE", "/etc/ansible/inventories")
    
    # Inventory Configurations
    INVENTORY_GROUPS = {
        "dev": {
            "core": "dev/core.ini",
            "jboss": "dev/jboss.ini",
            "all": "dev/all.ini"
        },
        "perf": {
            "core": "perf/core.ini", 
            "jboss": "perf/jboss.ini",
            "all": "perf/all.ini"
        },
        "esqm": {
            "core": "esqm/core.ini",
            "jboss": "esqm/jboss.ini", 
            "all": "esqm/all.ini"
        }
    }
    
    # Execution Settings
    COMMAND_BLOCKLIST = [
        "rm -rf /", "mkfs", ":(){:|:&};:", "shutdown", "reboot",
        "halt", "poweroff", "dd if=", "fdisk", "parted", "init 0", "init 6"
    ]
    MAX_COMMAND_LENGTH = 2000
    COMMAND_TIMEOUT = 600
    
    # WebSocket Settings
    WS_POLL_INTERVAL = 0.5

settings = Settings()


app/models.py
--------------
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum

class ServerEnvironment(str, Enum):
    DEV = "dev"
    PERF = "perf" 
    ESQM = "esqm"

class ServerRole(str, Enum):
    CORE = "core"
    JBOSS = "jboss"
    ALL = "all"

class CommandRequest(BaseModel):
    command: str = Field(..., min_length=1, max_length=2000)
    environment: ServerEnvironment
    role: ServerRole
    timeout: Optional[int] = 600

class ExecutionResponse(BaseModel):
    execution_id: str
    status: str
    message: Optional[str] = None

class HostResult(BaseModel):
    host: str
    status: str
    output: str
    error: Optional[str] = None
    return_code: Optional[int] = None

class ExecutionResult(BaseModel):
    execution_id: str
    status: str
    results: List[HostResult]
    summary: Dict[str, Any]


app/services/ansible_service.py
--------------------------------
import asyncio
import asyncssh
import tempfile
import uuid
import os
from typing import List, Dict, Any, AsyncGenerator
from pathlib import Path
from ..config import settings
from ..models import HostResult, ExecutionResult

class AnsibleService:
    def __init__(self):
        self.ssh_conn = None
        
    async def connect(self):
        """Connect to Ansible node via SSH"""
        if self.ssh_conn is None:
            self.ssh_conn = await asyncssh.connect(
                settings.ANSIBLE_NODE_HOST,
                username=settings.ANSIBLE_NODE_USER,
                client_keys=[settings.ANSIBLE_NODE_SSH_KEY_PATH],
                known_hosts=None
            )
        return self.ssh_conn
    
    async def close(self):
        """Close SSH connection"""
        if self.ssh_conn:
            self.ssh_conn.close()
            self.ssh_conn = None
    
    def get_inventory_path(self, environment: str, role: str) -> str:
        """Get inventory file path for environment and role"""
        if environment not in settings.INVENTORY_GROUPS:
            raise ValueError(f"Unknown environment: {environment}")
        
        if role not in settings.INVENTORY_GROUPS[environment]:
            raise ValueError(f"Unknown role: {role} for environment: {environment}")
        
        return str(Path(settings.ANSIBLE_INVENTORY_BASE) / 
                  settings.INVENTORY_GROUPS[environment][role])
    
    async def execute_ad_hoc_command(
        self, 
        command: str, 
        environment: str, 
        role: str,
        timeout: int = 600
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Execute ad-hoc command on Ansible node and stream results"""
        conn = await self.connect()
        execution_id = str(uuid.uuid4())
        inventory_path = self.get_inventory_path(environment, role)
        
        # Build ansible command
        ansible_cmd = [
            "ansible",
            "-i", inventory_path,
            role,
            "-m", "shell",
            "-a", f"'{command}'",
            "--timeout", str(timeout),
            "-o"
        ]
        
        cmd_str = " ".join(ansible_cmd)
        
        try:
            # Execute command and stream output
            async with conn.create_process(cmd_str) as process:
                async for line in process.stdout:
                    if line.strip():
                        yield self._parse_ansible_output(line, execution_id)
                        
        except asyncssh.Error as e:
            yield {
                "execution_id": execution_id,
                "type": "error",
                "data": {"message": f"SSH Error: {str(e)}"}
            }
        except Exception as e:
            yield {
                "execution_id": execution_id, 
                "type": "error",
                "data": {"message": f"Execution Error: {str(e)}"}
            }
    
    def _parse_ansible_output(self, line: str, execution_id: str) -> Dict[str, Any]:
        """Parse Ansible command output line"""
        try:
            # Example: "server01 | CHANGED | rc=0 | (stdout) disk usage info"
            if "|" in line:
                parts = line.split("|", 3)
                if len(parts) >= 4:
                    host = parts[0].strip()
                    status = parts[1].strip().lower()
                    rc_part = parts[2].strip()
                    output = parts[3].strip()
                    
                    # Extract return code
                    return_code = 0
                    if "rc=" in rc_part:
                        try:
                            return_code = int(rc_part.split("=")[1])
                        except (IndexError, ValueError):
                            pass
                    
                    return {
                        "execution_id": execution_id,
                        "type": "host_result",
                        "data": {
                            "host": host,
                            "status": status,
                            "output": output,
                            "return_code": return_code
                        }
                    }
            
            # Return raw output for unparsable lines
            return {
                "execution_id": execution_id,
                "type": "raw_output",
                "data": {"output": line}
            }
            
        except Exception as e:
            return {
                "execution_id": execution_id,
                "type": "error",
                "data": {"message": f"Parse error: {str(e)}", "output": line}
            }
    
    async def run_playbook(
        self,
        playbook_content: str,
        environment: str,
        role: str,
        timeout: int = 600
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Execute Ansible playbook and stream results"""
        conn = await self.connect()
        execution_id = str(uuid.uuid4())
        inventory_path = self.get_inventory_path(environment, role)
        
        # Create temporary playbook file on Ansible node
        temp_playbook = f"/tmp/playbook_{execution_id}.yml"
        
        try:
            # Upload playbook
            async with conn.start_sftp_client() as sftp:
                async with sftp.open(temp_playbook, 'w') as f:
                    await f.write(playbook_content)
            
            # Execute playbook
            ansible_cmd = [
                "ansible-playbook",
                "-i", inventory_path,
                "--limit", role,
                "--timeout", str(timeout),
                temp_playbook
            ]
            
            cmd_str = " ".join(ansible_cmd)
            
            async with conn.create_process(cmd_str) as process:
                async for line in process.stdout:
                    if line.strip():
                        yield self._parse_playbook_output(line, execution_id)
                        
        except Exception as e:
            yield {
                "execution_id": execution_id,
                "type": "error", 
                "data": {"message": f"Playbook error: {str(e)}"}
            }
        finally:
            # Clean up temporary file
            try:
                async with conn.create_process(f"rm -f {temp_playbook}") as process:
                    await process.wait()
            except:
                pass
    
    def _parse_playbook_output(self, line: str, execution_id: str) -> Dict[str, Any]:
        """Parse Ansible playbook output line"""
        # Simplified parsing - in production you'd want more sophisticated parsing
        return {
            "execution_id": execution_id,
            "type": "playbook_output",
            "data": {"output": line}
        }

# Global service instance
ansible_service = AnsibleService()

app/services/websocket_manager.py
---------------------------------
import asyncio
from typing import Dict, Set, Callable, Any
from fastapi import WebSocket
import json

class WebSocketManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.execution_handlers: Dict[str, asyncio.Task] = {}
        self.subscriptions: Dict[str, Set[str]] = {}  # execution_id -> set of connection IDs
        
    async def connect(self, websocket: WebSocket, connection_id: str):
        await websocket.accept()
        self.active_connections[connection_id] = websocket
        
    def disconnect(self, connection_id: str):
        if connection_id in self.active_connections:
            del self.active_connections[connection_id]
        
        # Remove from subscriptions
        for execution_id, subscribers in self.subscriptions.items():
            if connection_id in subscribers:
                subscribers.remove(connection_id)
    
    async def subscribe(self, connection_id: str, execution_id: str):
        if execution_id not in self.subscriptions:
            self.subscriptions[execution_id] = set()
        self.subscriptions[execution_id].add(connection_id)
    
    async def unsubscribe(self, connection_id: str, execution_id: str):
        if execution_id in self.subscriptions and connection_id in self.subscriptions[execution_id]:
            self.subscriptions[execution_id].remove(connection_id)
    
    async def broadcast(self, execution_id: str, message: Dict[str, Any]):
        """Broadcast message to all subscribers of an execution"""
        if execution_id in self.subscriptions:
            for connection_id in self.subscriptions[execution_id]:
                if connection_id in self.active_connections:
                    try:
                        await self.active_connections[connection_id].send_json(message)
                    except Exception as e:
                        print(f"Error sending to {connection_id}: {e}")
                        self.disconnect(connection_id)
    
    async def start_execution_stream(
        self,
        execution_id: str,
        stream_generator: Callable[[], Any],
        initial_message: Dict[str, Any] = None
    ):
        """Start streaming execution results to subscribers"""
        if initial_message:
            await self.broadcast(execution_id, initial_message)
        
        try:
            async for message in stream_generator:
                await self.broadcast(execution_id, message)
                
                # Check if execution is complete
                if message.get('type') in ['complete', 'error']:
                    break
                    
        except Exception as e:
            error_msg = {
                "execution_id": execution_id,
                "type": "error",
                "data": {"message": f"Stream error: {str(e)}"}
            }
            await self.broadcast(execution_id, error_msg)
        finally:
            # Clean up
            if execution_id in self.execution_handlers:
                del self.execution_handlers[execution_id]
            if execution_id in self.subscriptions:
                del self.subscriptions[execution_id]

# Global WebSocket manager
websocket_manager = WebSocketManager()

app/routes/commands.py
-------------------------
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
import asyncio
from ..dependencies import get_token_header
from ..models import CommandRequest, ExecutionResponse, ServerEnvironment, ServerRole
from ..services.ansible_service import ansible_service
from ..services.websocket_manager import websocket_manager
from ..config import settings

router = APIRouter(
    prefix="/commands",
    tags=["commands"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)

@router.get("/environments")
async def get_environments():
    """Get available environments"""
    return [env.value for env in ServerEnvironment]

@router.get("/roles")
async def get_roles():
    """Get available roles"""
    return [role.value for role in ServerRole]

@router.post("/execute", response_model=ExecutionResponse)
async def execute_command(request: CommandRequest):
    """Execute command on selected servers"""
    # Validate command
    if len(request.command) > settings.MAX_COMMAND_LENGTH:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Command exceeds maximum length of {settings.MAX_COMMAND_LENGTH} characters"
        )
    
    # Check for blocked commands
    for blocked_cmd in settings.COMMAND_BLOCKLIST:
        if blocked_cmd in request.command:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Command contains blocked pattern: {blocked_cmd}"
            )
    
    execution_id = str(uuid.uuid4())
    
    # Start execution in background
    asyncio.create_task(
        _stream_command_execution(
            execution_id, 
            request.command, 
            request.environment.value, 
            request.role.value,
            request.timeout
        )
    )
    
    return ExecutionResponse(
        execution_id=execution_id,
        status="started",
        message="Command execution started. Connect via WebSocket for real-time results."
    )

async def _stream_command_execution(execution_id: str, command: str, environment: str, role: str, timeout: int):
    """Stream command execution results via WebSocket"""
    initial_message = {
        "execution_id": execution_id,
        "type": "start",
        "data": {
            "command": command,
            "environment": environment,
            "role": role,
            "timeout": timeout
        }
    }
    
    # Create stream generator
    async def command_stream():
        async for result in ansible_service.execute_ad_hoc_command(command, environment, role, timeout):
            yield result
        
        # Send completion message
        yield {
            "execution_id": execution_id,
            "type": "complete",
            "data": {"message": "Command execution completed"}

   # Start streaming
    await websocket_manager.start_execution_stream(execution_id, command_stream, initial_message)


app/routes/ws.py
------------------
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import uuid
from ..services.websocket_manager import websocket_manager

router = APIRouter(
    prefix="/ws",
    tags=["websocket"],
)

@router.websocket("/execution/{execution_id}")
async def websocket_execution(websocket: WebSocket, execution_id: str):
    """WebSocket endpoint for real-time execution updates"""
    connection_id = str(uuid.uuid4())
    
    await websocket_manager.connect(websocket, connection_id)
    await websocket_manager.subscribe(connection_id, execution_id)
    
    try:
        while True:
            # Keep connection alive and handle messages
            data = await websocket.receive_text()
            # Handle client messages if needed
            if data == "ping":
                await websocket.send_text("pong")
                
    except WebSocketDisconnect:
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, execution_id)
    except Exception as e:
        print(f"WebSocket error: {e}")
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, execution_id)

app/dependencies.py
------------------

from fastapi import Header, HTTPException, status
from .config import settings

async def get_token_header(x_token: str = Header(...)):
    if x_token != settings.API_TOKEN:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API token",
        )
    return x_token


app/main.py
------------
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .config import settings
from .routes import commands, ws
from .services.ansible_service import ansible_service
import asyncio

app = FastAPI(
    title=settings.API_TITLE,
    version=settings.API_VERSION,
    description=settings.API_DESCRIPTION
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(commands.router)
app.include_router(ws.router)

@app.get("/")
async def root():
    return {"message": "Ansible API Wrapper"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    await ansible_service.connect()

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup services on shutdown"""
    await ansible_service.close()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


pip install -r requirements.txt
---------------------------------

# .env file
API_TOKEN=your-secure-api-token
ANSIBLE_NODE_HOST=your-ansible-node.example.com
ANSIBLE_NODE_USER=ansible-user
ANSIBLE_NODE_SSH_KEY_PATH=~/.ssh/id_rsa
ANSIBLE_INVENTORY_BASE=/etc/ansible/inventories
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173


uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

http://localhost:8000/docs
