app/models.py
--------------
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any, Union
from enum import Enum
import uuid

# ... existing models ...

class FileUploadRequest(BaseModel):
    environment: ServerEnvironment
    role: ServerRole
    target_path: str = Field(..., description="Target path on remote servers")
    overwrite: bool = Field(False, description="Overwrite existing files")

class FileUploadResponse(BaseModel):
    upload_id: str
    status: str
    message: Optional[str] = None
    file_info: Optional[Dict[str, Any]] = None

class UploadStatus(str, Enum):
    PENDING = "pending"
    UPLOADING = "uploading"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

class FileUploadStatus(BaseModel):
    upload_id: str
    status: UploadStatus
    progress: int = Field(0, ge=0, le=100)
    message: Optional[str] = None
    results: Optional[Dict[str, Any]] = None


app/services/file_upload_service.py
-----------------------------------
import os
import asyncio
import asyncssh
import tempfile
import shutil
import uuid
from pathlib import Path
from typing import Dict, List, Any, AsyncGenerator
from fastapi import UploadFile, HTTPException
from ..config import settings
from ..models import FileUploadRequest, UploadStatus

class FileUploadService:
    def __init__(self):
        self.ssh_conn = None
        self.upload_cache = {}  # Store upload status

    async def connect(self):
        """Connect to Ansible node via SSH"""
        if self.ssh_conn is None:
            self.ssh_conn = await asyncssh.connect(
                settings.ANSIBLE_NODE_HOST,
                username=settings.ANSIBLE_NODE_USER,
                client_keys=[settings.ANSIBLE_NODE_SSH_KEY_PATH],
                known_hosts=None
            )
        return self.ssh_conn

    async def close(self):
        """Close SSH connection"""
        if self.ssh_conn:
            self.ssh_conn.close()
            self.ssh_conn = None

    def get_inventory_path(self, environment: str, role: str) -> str:
        """Get inventory file path for environment and role"""
        if environment not in settings.INVENTORY_GROUPS:
            raise ValueError(f"Unknown environment: {environment}")
        
        if role not in settings.INVENTORY_GROUPS[environment]:
            raise ValueError(f"Unknown role: {role} for environment: {environment}")
        
        return str(Path(settings.ANSIBLE_INVENTORY_BASE) / 
                  settings.INVENTORY_GROUPS[environment][role])

    async def parse_inventory_hosts(self, environment: str, role: str) -> List[str]:
        """Parse inventory and get list of hosts"""
        inventory_path = self.get_inventory_path(environment, role)
        conn = await self.connect()
        
        try:
            # Read and parse inventory file
            async with conn.create_process(f"cat {inventory_path} | grep -v '^#' | grep -v '^$' | grep -v '\\['") as process:
                hosts = []
                async for line in process.stdout:
                    line = line.strip()
                    if line and 'ansible_host' not in line:
                        host = line.split()[0]  # Get first part (hostname)
                        hosts.append(host)
                return hosts
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to parse inventory: {str(e)}")

    async def upload_and_distribute_file(
        self,
        upload_id: str,
        file: UploadFile,
        request: FileUploadRequest,
        chunk_size: int = 1024 * 1024  # 1MB chunks
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Upload file and distribute to target servers"""
        try:
            # Update status
            self.upload_cache[upload_id] = {
                "status": UploadStatus.UPLOADING,
                "progress": 0,
                "message": "Starting file upload"
            }

            # Get target hosts
            hosts = await self.parse_inventory_hosts(request.environment.value, request.role.value)
            total_hosts = len(hosts)
            
            if total_hosts == 0:
                raise HTTPException(status_code=400, detail="No hosts found for the selected environment and role")

            # Create temporary file on Ansible node
            conn = await self.connect()
            temp_filename = f"/tmp/upload_{upload_id}_{file.filename}"
            
            # Upload file to Ansible node
            async with conn.start_sftp_client() as sftp:
                # Update status
                self.upload_cache[upload_id] = {
                    "status": UploadStatus.UPLOADING,
                    "progress": 10,
                    "message": "Uploading file to Ansible node"
                }

                # Upload file in chunks
                async with sftp.open(temp_filename, 'wb') as remote_file:
                    total_size = 0
                    while chunk := await file.read(chunk_size):
                        await remote_file.write(chunk)
                        total_size += len(chunk)
                        
                        # Update progress
                        progress = min(20, 10 + (total_size / (10 * 1024 * 1024)) * 10)  # Estimate based on 10MB max
                        self.upload_cache[upload_id]["progress"] = progress

            # Update status
            self.upload_cache[upload_id] = {
                "status": UploadStatus.PROCESSING,
                "progress": 25,
                "message": "File uploaded to Ansible node, starting distribution"
            }

            yield {
                "upload_id": upload_id,
                "type": "status",
                "data": self.upload_cache[upload_id]
            }

            # Distribute file to target hosts
            successful_hosts = []
            failed_hosts = []

            for i, host in enumerate(hosts):
                try:
                    # Update progress
                    progress = 25 + (i / total_hosts) * 70
                    self.upload_cache[upload_id] = {
                        "status": UploadStatus.PROCESSING,
                        "progress": int(progress),
                        "message": f"Copying to {host} ({i+1}/{total_hosts})"
                    }

                    yield {
                        "upload_id": upload_id,
                        "type": "status",
                        "data": self.upload_cache[upload_id]
                    }

                    # Copy file to target host
                    copy_cmd = [
                        "ansible",
                        host,
                        "-m", "copy",
                        "-a", f"src={temp_filename} dest={request.target_path}",
                        "--timeout", "300"
                    ]

                    if request.overwrite:
                        copy_cmd[-1] = copy_cmd[-1] + " force=yes"

                    async with conn.create_process(" ".join(copy_cmd)) as process:
                        output = []
                        async for line in process.stdout:
                            output.append(line)
                        
                        if process.returncode == 0:
                            successful_hosts.append(host)
                        else:
                            failed_hosts.append({"host": host, "error": "\n".join(output)})

                except Exception as e:
                    failed_hosts.append({"host": host, "error": str(e)})

            # Clean up temporary file
            try:
                async with conn.create_process(f"rm -f {temp_filename}") as process:
                    await process.wait()
            except:
                pass

            # Final status
            if failed_hosts:
                status = UploadStatus.FAILED if len(failed_hosts) == total_hosts else UploadStatus.COMPLETED
                message = f"Completed with {len(successful_hosts)} successes and {len(failed_hosts)} failures"
            else:
                status = UploadStatus.COMPLETED
                message = "All files copied successfully"

            self.upload_cache[upload_id] = {
                "status": status,
                "progress": 100,
                "message": message,
                "results": {
                    "successful_hosts": successful_hosts,
                    "failed_hosts": failed_hosts,
                    "total_hosts": total_hosts,
                    "filename": file.filename,
                    "target_path": request.target_path
                }
            }

            yield {
                "upload_id": upload_id,
                "type": "complete",
                "data": self.upload_cache[upload_id]
            }

        except Exception as e:
            self.upload_cache[upload_id] = {
                "status": UploadStatus.FAILED,
                "progress": 100,
                "message": f"Upload failed: {str(e)}"
            }
            yield {
                "upload_id": upload_id,
                "type": "error",
                "data": {"message": str(e)}
            }

    def get_upload_status(self, upload_id: str) -> Dict[str, Any]:
        """Get current upload status"""
        return self.upload_cache.get(upload_id, {
            "status": UploadStatus.FAILED,
            "progress": 0,
            "message": "Upload ID not found"
        })

    def cleanup_upload(self, upload_id: str):
        """Clean up upload data"""
        if upload_id in self.upload_cache:
            del self.upload_cache[upload_id]

# Global service instance
file_upload_service = FileUploadService()


app/routes/uploads.py
-----------------------
from fastapi import APIRouter, UploadFile, File, Form, HTTPException, Depends
from fastapi import BackgroundTasks
from typing import List
import uuid
import asyncio
from ..dependencies import get_token_header
from ..models import FileUploadRequest, FileUploadResponse, FileUploadStatus
from ..services.file_upload_service import file_upload_service
from ..services.websocket_manager import websocket_manager

router = APIRouter(
    prefix="/uploads",
    tags=["uploads"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)

@router.post("/file", response_model=FileUploadResponse)
async def upload_file(
    background_tasks: BackgroundTasks,
    environment: str = Form(...),
    role: str = Form(...),
    target_path: str = Form(...),
    overwrite: bool = Form(False),
    file: UploadFile = File(...)
):
    """Upload a file and distribute to target servers"""
    # Validate file
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file provided")
    
    # Validate target path
    if not target_path.startswith('/'):
        raise HTTPException(status_code=400, detail="Target path must be absolute")
    
    # Create upload request
    upload_request = FileUploadRequest(
        environment=environment,
        role=role,
        target_path=target_path,
        overwrite=overwrite
    )
    
    # Generate upload ID
    upload_id = str(uuid.uuid4())
    
    # Start upload process in background
    background_tasks.add_task(
        _process_file_upload,
        upload_id,
        file,
        upload_request
    )
    
    return FileUploadResponse(
        upload_id=upload_id,
        status="started",
        message="File upload started",
        file_info={
            "filename": file.filename,
            "content_type": file.content_type,
            "size": file.size
        }
    )

@router.post("/directory", response_model=FileUploadResponse)
async def upload_directory(
    background_tasks: BackgroundTasks,
    environment: str = Form(...),
    role: str = Form(...),
    target_path: str = Form(...),
    overwrite: bool = Form(False),
    files: List[UploadFile] = File(...)
):
    """Upload multiple files (directory) and distribute to target servers"""
    if not files:
        raise HTTPException(status_code=400, detail="No files provided")
    
    # Validate target path
    if not target_path.startswith('/'):
        raise HTTPException(status_code=400, detail="Target path must be absolute")
    
    # Create upload request
    upload_request = FileUploadRequest(
        environment=environment,
        role=role,
        target_path=target_path,
        overwrite=overwrite
    )
    
    # Generate upload ID
    upload_id = str(uuid.uuid4())
    
    # Start upload process in background
    background_tasks.add_task(
        _process_directory_upload,
        upload_id,
        files,
        upload_request
    )
    
    return FileUploadResponse(
        upload_id=upload_id,
        status="started",
        message="Directory upload started",
        file_info={
            "file_count": len(files),
            "filenames": [f.filename for f in files]
        }
    )

@router.get("/status/{upload_id}", response_model=FileUploadStatus)
async def get_upload_status(upload_id: str):
    """Get status of a file upload"""
    status = file_upload_service.get_upload_status(upload_id)
    return FileUploadStatus(**status)

async def _process_file_upload(upload_id: str, file: UploadFile, request: FileUploadRequest):
    """Process file upload in background"""
    try:
        async for message in file_upload_service.upload_and_distribute_file(upload_id, file, request):
            await websocket_manager.broadcast(upload_id, message)
    except Exception as e:
        error_message = {
            "upload_id": upload_id,
            "type": "error",
            "data": {"message": f"Upload processing failed: {str(e)}"}
        }
        await websocket_manager.broadcast(upload_id, error_message)
    finally:
        # Clean up after 1 hour
        await asyncio.sleep(3600)
        file_upload_service.cleanup_upload(upload_id)

async def _process_directory_upload(upload_id: str, files: List[UploadFile], request: FileUploadRequest):
    """Process directory upload in background"""
    # This would be similar to _process_file_upload but handling multiple files
    # Implementation would depend on your specific requirements
    pass


app/routes/ws.py
------------------
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import uuid
from ..services.websocket_manager import websocket_manager

router = APIRouter(
    prefix="/ws",
    tags=["websocket"],
)

@router.websocket("/execution/{execution_id}")
async def websocket_execution(websocket: WebSocket, execution_id: str):
    """WebSocket endpoint for real-time execution updates"""
    connection_id = str(uuid.uuid4())
    
    await websocket_manager.connect(websocket, connection_id)
    await websocket_manager.subscribe(connection_id, execution_id)
    
    try:
        while True:
            # Keep connection alive and handle messages
            data = await websocket.receive_text()
            # Handle client messages if needed
            if data == "ping":
                await websocket.send_text("pong")
                
    except WebSocketDisconnect:
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, execution_id)
    except Exception as e:
        print(f"WebSocket error: {e}")
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, execution_id)

@router.websocket("/upload/{upload_id}")
async def websocket_upload(websocket: WebSocket, upload_id: str):
    """WebSocket endpoint for real-time upload updates"""
    connection_id = str(uuid.uuid4())
    
    await websocket_manager.connect(websocket, connection_id)
    await websocket_manager.subscribe(connection_id, upload_id)
    
    try:
        while True:
            # Keep connection alive and handle messages
            data = await websocket.receive_text()
            if data == "ping":
                await websocket.send_text("pong")
                
    except WebSocketDisconnect:
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, upload_id)
    except Exception as e:
        print(f"WebSocket upload error: {e}")
        websocket_manager.disconnect(connection_id)
        await websocket_manager.unsubscribe(connection_id, upload_id)


app/main.py
------------
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import os
from .config import settings
from .routes import commands, ws, uploads  # Add uploads import
from .services.ansible_service import ansible_service
from .services.file_upload_service import file_upload_service  # Add this import
import asyncio

app = FastAPI(
    title=settings.API_TITLE,
    version=settings.API_VERSION,
    description=settings.API_DESCRIPTION
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(commands.router)
app.include_router(ws.router)
app.include_router(uploads.router)  # Add this line

# Serve static files for uploads
app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")

@app.get("/")
async def root():
    return {"message": "Ansible API Wrapper"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    await ansible_service.connect()
    await file_upload_service.connect()  # Add this line

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup services on shutdown"""
    await ansible_service.close()
    await file_upload_service.close()  # Add this line

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)



rc/services/fileUploadService.js

import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || '/api';
const API_TOKEN = process.env.REACT_APP_API_TOKEN || 'dev-token-default-change-in-production';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'multipart/form-data'
  }
});

// Add token to all requests
api.interceptors.request.use((config) => {
  config.headers['x-token'] = API_TOKEN;
  return config;
});

export const fileUploadApi = {
  // Upload single file
  uploadFile: (formData) => api.post('/uploads/file', formData),
  
  // Upload multiple files (directory)
  uploadDirectory: (formData) => api.post('/uploads/directory', formData),
  
  // Get upload status
  getUploadStatus: (uploadId) => api.get(`/uploads/status/${uploadId}`),
};

export default fileUploadApi;


src/components/AnsibleCommand/FileUpload.jsx
----------------------------------------------
import React, { useState, useRef } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Checkbox,
  LinearProgress,
  Alert,
  Chip,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemIcon
} from '@mui/material';
import {
  CloudUpload as CloudUploadIcon,
  Folder as FolderIcon,
  InsertDriveFile as FileIcon,
  Cancel as CancelIcon
} from '@mui/icons-material';
import { fileUploadApi } from '../../services/fileUploadApi';
import { websocketService } from '../../services/websocketService';
import './FileUpload.css';

const FileUpload = ({ environments, roles }) => {
  const [selectedEnv, setSelectedEnv] = useState('');
  const [selectedRole, setSelectedRole] = useState('');
  const [targetPath, setTargetPath] = useState('');
  const [overwrite, setOverwrite] = useState(false);
  const [files, setFiles] = useState([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadId, setUploadId] = useState(null);
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState('idle');
  const [message, setMessage] = useState('');
  const [results, setResults] = useState(null);
  
  const fileInputRef = useRef(null);
  const directoryInputRef = useRef(null);

  const handleFileSelect = (event) => {
    const selectedFiles = Array.from(event.target.files);
    setFiles(selectedFiles);
  };

  const handleDirectorySelect = (event) => {
    const selectedFiles = Array.from(event.target.files);
    setFiles(selectedFiles);
  };

  const removeFile = (index) => {
    setFiles(prev => prev.filter((_, i) => i !== index));
  };

  const handleWebSocketMessage = (message) => {
    switch (message.type) {
      case 'status':
        setProgress(message.data.progress);
        setStatus(message.data.status);
        setMessage(message.data.message);
        break;
      
      case 'complete':
        setProgress(100);
        setStatus('completed');
        setMessage(message.data.message);
        setResults(message.data.results);
        setIsUploading(false);
        break;
      
      case 'error':
        setStatus('error');
        setMessage(message.data.message);
        setIsUploading(false);
        break;
      
      default:
        console.log('Unknown message type:', message.type);
    }
  };

  const uploadFiles = async () => {
    if (!files.length || !selectedEnv || !selectedRole || !targetPath) {
      setMessage('Please select files, environment, role, and target path');
      return;
    }

    setIsUploading(true);
    setStatus('uploading');
    setMessage('Starting upload...');
    setResults(null);

    try {
      const formData = new FormData();
      formData.append('environment', selectedEnv);
      formData.append('role', selectedRole);
      formData.append('target_path', targetPath);
      formData.append('overwrite', overwrite);

      // Add all files to form data
      files.forEach(file => {
        formData.append('files', file);
      });

      const response = await fileUploadApi.uploadDirectory(formData);
      const uploadId = response.data.upload_id;
      setUploadId(uploadId);

      // Connect to WebSocket for real-time updates
      websocketService.addMessageHandler(handleWebSocketMessage);
      websocketService.connect(uploadId, process.env.REACT_APP_API_TOKEN, 'upload');

    } catch (error) {
      setStatus('error');
      setMessage(error.response?.data?.detail || 'Upload failed');
      setIsUploading(false);
    }
  };

  const cancelUpload = () => {
    websocketService.disconnect();
    setIsUploading(false);
    setStatus('cancelled');
    setMessage('Upload cancelled by user');
  };

  const resetForm = () => {
    setFiles([]);
    setSelectedEnv('');
    setSelectedRole('');
    setTargetPath('');
    setOverwrite(false);
    setProgress(0);
    setStatus('idle');
    setMessage('');
    setResults(null);
    setUploadId(null);
    
    if (fileInputRef.current) fileInputRef.current.value = '';
    if (directoryInputRef.current) directoryInputRef.current.value = '';
  };

  return (
    <Paper className="file-upload-container" elevation={2}>
      <Typography variant="h6" gutterBottom>
        File Upload to Servers
      </Typography>

      <Box className="upload-form">
        <FormControl fullWidth margin="normal">
          <InputLabel>Environment</InputLabel>
          <Select
            value={selectedEnv}
            label="Environment"
            onChange={(e) => setSelectedEnv(e.target.value)}
            disabled={isUploading}
          >
            <MenuItem value="">Select Environment</MenuItem>
            {environments.map(env => (
              <MenuItem key={env} value={env}>
                {env.toUpperCase()}
              </MenuItem>
            ))}
          </Select>
        </FormControl>

        <FormControl fullWidth margin="normal">
          <InputLabel>Server Role</InputLabel>
          <Select
            value={selectedRole}
            label="Server Role"
            onChange={(e) => setSelectedRole(e.target.value)}
            disabled={isUploading || !selectedEnv}
          >
            <MenuItem value="">Select Role</MenuItem>
            {roles.map(role => (
              <MenuItem key={role} value={role}>
                {role}
              </MenuItem>
            ))}
          </Select>
        </FormControl>

        <TextField
          fullWidth
          margin="normal"
          label="Target Path on Servers"
          placeholder="/path/on/target/servers/"
          value={targetPath}
          onChange={(e) => setTargetPath(e.target.value)}
          disabled={isUploading}
          helperText="Absolute path where files should be copied"
        />

        <FormControlLabel
          control={
            <Checkbox
              checked={overwrite}
              onChange={(e) => setOverwrite(e.target.checked)}
              disabled={isUploading}
            />
          }
          label="Overwrite existing files"
        />

        <Box className="file-selection" sx={{ mt: 2 }}>
          <input
            ref={fileInputRef}
            type="file"
            multiple
            onChange={handleFileSelect}
            disabled={isUploading}
            style={{ display: 'none' }}
          />
          <input
            ref={directoryInputRef}
            type="file"
            multiple
            webkitdirectory="true"
            onChange={handleDirectorySelect}
            disabled={isUploading}
            style={{ display: 'none' }}
          />

          <Button
            variant="outlined"
            startIcon={<FileIcon />}
            onClick={() => fileInputRef.current?.click()}
            disabled={isUploading}
            sx={{ mr: 1 }}
          >
            Select Files
          </Button>

          <Button
            variant="outlined"
            startIcon={<FolderIcon />}
            onClick={() => directoryInputRef.current?.click()}
            disabled={isUploading}
          >
            Select Folder
          </Button>
        </Box>

        {files.length > 0 && (
          <Box className="file-list" sx={{ mt: 2 }}>
            <Typography variant="subtitle2">Selected Files:</Typography>
            <List dense>
              {files.map((file, index) => (
                <ListItem key={index} secondaryAction={
                  <IconButton
                    edge="end"
                    onClick={() => removeFile(index)}
                    disabled={isUploading}
                  >
                    <CancelIcon />
                  </IconButton>
                }>
                  <ListItemIcon>
                    <FileIcon />
                  </ListItemIcon>
                  <ListItemText
                    primary={file.name}
                    secondary={`${(file.size / 1024).toFixed(2)} KB`}
                  />
                </ListItem>
              ))}
            </List>
          </Box>
        )}

        <Box className="upload-actions" sx={{ mt: 2 }}>
          <Button
            variant="contained"
            color="primary"
            startIcon={<CloudUploadIcon />}
            onClick={uploadFiles}
            disabled={isUploading || files.length === 0 || !selectedEnv || !selectedRole || !targetPath}
            fullWidth
          >
            {isUploading ? 'Uploading...' : 'Upload to Servers'}
          </Button>

          {isUploading && (
            <Button
              variant="outlined"
              color="secondary"
              onClick={cancelUpload}
              fullWidth
              sx={{ mt: 1 }}
            >
              Cancel Upload
            </Button>
          )}

          {!isUploading && (status === 'completed' || status === 'error') && (
            <Button
              variant="outlined"
              onClick={resetForm}
              fullWidth
              sx={{ mt: 1 }}
            >
              Start New Upload
            </Button>
          )}
        </Box>

        {isUploading && (
          <Box sx={{ mt: 2 }}>
            <LinearProgress variant="determinate" value={progress} />
            <Typography variant="body2" sx={{ mt: 1 }}>
              Progress: {progress}% - {message}
            </Typography>
          </Box>
        )}

        {message && !isUploading && (
          <Alert
            severity={
              status === 'completed' ? 'success' :
              status === 'error' ? 'error' :
              status === 'cancelled' ? 'warning' : 'info'
            }
            sx={{ mt: 2 }}
          >
            {message}
          </Alert>
        )}

        {results && (
          <Box className="upload-results" sx={{ mt: 2 }}>
            <Typography variant="subtitle2">Results:</Typography>
            <Chip
              label={`Successful: ${results.successful_hosts.length}/${results.total_hosts}`}
              color="success"
              size="small"
              sx={{ mr: 1 }}
            />
            <Chip
              label={`Failed: ${results.failed_hosts.length}`}
              color="error"
              size="small"
            />
          </Box>
        )}

        {uploadId && (
          <Typography variant="caption" display="block" sx={{ mt: 1 }}>
            Upload ID: {uploadId}
          </Typography>
        )}
      </Box>
    </Paper>
  );
};

export default FileUpload;


src/components/AnsibleCommand/FileUpload.css
---------------------------------------------
.file-upload-container {
  padding: 20px;
  margin-bottom: 20px;
}

.upload-form {
  max-width: 600px;
}

.file-selection {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.file-list {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  padding: 10px;
}

.upload-actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.upload-results {
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
}



// In src/components/AnsibleCommand/AnsibleCommand.jsx
import FileUpload from './FileUpload';

// Add this to your component render method:
<Grid item xs={12}>
  <FileUpload environments={environments} roles={roles} />
</Grid>
