package com.example.auditdemo.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.GenericGenerator;

import java.time.LocalDateTime;

@Entity
@Table(name = "AUDIT_LOGS", schema = "AUDIT_SCHEMA")
@Data
@NoArgsConstructor
@AllArgsConstructor
@SequenceGenerator(name = "audit_log_seq", sequenceName = "AUDIT_LOG_SEQ", allocationSize = 1)
public class AuditLog {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "audit_log_seq")
    @Column(name = "ID", precision = 19)
    private Long id;
    
    @Column(name = "USERNAME", nullable = false, length = 255)
    private String username;
    
    @Column(name = "API_ENDPOINT", nullable = false, length = 1000)
    private String apiEndpoint;
    
    @Column(name = "HTTP_METHOD", nullable = false, length = 10)
    private String httpMethod;
    
    @Lob
    @Column(name = "REQUEST_BODY")
    private String requestBody;
    
    @Lob
    @Column(name = "RESPONSE_BODY")
    private String responseBody;
    
    @Column(name = "HTTP_STATUS", nullable = false, precision = 10)
    private Integer httpStatus;
    
    @Column(name = "CLIENT_IP", length = 45)
    private String clientIp;
    
    @Column(name = "USER_AGENT", length = 1000)
    private String userAgent;
    
    @Column(name = "EXECUTION_TIME", precision = 19)
    private Long executionTime; // in milliseconds
    
    @Column(name = "CREATED_AT", nullable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @Column(name = "ERROR_MESSAGE", length = 4000)
    private String errorMessage;
    
    @Column(name = "SERVICE_NAME", length = 100)
    private String serviceName;
    
    @Column(name = "CORRELATION_ID", length = 100)
    private String correlationId;
    
    @Column(name = "SESSION_ID", length = 100)
    private String sessionId;
    
    @Lob
    @Column(name = "REQUEST_HEADERS")
    private String requestHeaders;
    
    @Column(name = "RESOURCE_ID", length = 100)
    private String resourceId;
    
    @Column(name = "ACTION_TYPE", length = 50)
    private String actionType; // CREATE, READ, UPDATE, DELETE
    
    @Column(name = "IS_SUCCESSFUL", length = 1)
    private String isSuccessful = "Y"; // Y/N
    
    @Column(name = "MODULE_NAME", length = 100)
    private String moduleName;
    
    @PrePersist
    public void prePersist() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (isSuccessful == null) {
            isSuccessful = httpStatus >= 200 && httpStatus < 300 ? "Y" : "N";
        }
    }
}


package com.example.auditdemo.repository;

import com.example.auditdemo.entity.AuditLog;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
    
    @Query("SELECT a FROM AuditLog a WHERE a.username = :username")
    Page<AuditLog> findByUsername(@Param("username") String username, Pageable pageable);
    
    @Query("SELECT a FROM AuditLog a WHERE UPPER(a.apiEndpoint) LIKE UPPER(CONCAT('%', :endpoint, '%'))")
    Page<AuditLog> findByApiEndpointContaining(@Param("endpoint") String endpoint, Pageable pageable);
    
    Page<AuditLog> findByHttpStatus(Integer httpStatus, Pageable pageable);
    
    @Query("SELECT a FROM AuditLog a WHERE a.createdAt BETWEEN :startDate AND :endDate")
    Page<AuditLog> findByCreatedAtBetween(@Param("startDate") LocalDateTime startDate, 
                                         @Param("endDate") LocalDateTime endDate, 
                                         Pageable pageable);
    
    @Query("SELECT a FROM AuditLog a WHERE " +
           "(:username IS NULL OR a.username = :username) AND " +
           "(:endpoint IS NULL OR UPPER(a.apiEndpoint) LIKE UPPER(CONCAT('%', :endpoint, '%'))) AND " +
           "(:method IS NULL OR a.httpMethod = :method) AND " +
           "(:status IS NULL OR a.httpStatus = :status) AND " +
           "(:success IS NULL OR a.isSuccessful = :success) AND " +
           "a.createdAt BETWEEN :startDate AND :endDate")
    Page<AuditLog> searchAuditLogs(@Param("username") String username,
                                  @Param("endpoint") String endpoint,
                                  @Param("method") String method,
                                  @Param("status") Integer status,
                                  @Param("success") String success,
                                  @Param("startDate") LocalDateTime startDate,
                                  @Param("endDate") LocalDateTime endDate,
                                  Pageable pageable);
    
    @Query("SELECT COUNT(a) FROM AuditLog a WHERE a.createdAt >= :date")
    Long countSince(@Param("date") LocalDateTime date);
    
    @Query("SELECT a.httpStatus, COUNT(a) FROM AuditLog a WHERE a.createdAt BETWEEN :start AND :end GROUP BY a.httpStatus")
    List<Object[]> getStatusCount(@Param("start") LocalDateTime start, 
                                 @Param("end") LocalDateTime end);
    
    @Query("SELECT a.username, COUNT(a) FROM AuditLog a WHERE a.createdAt BETWEEN :start AND :end GROUP BY a.username ORDER BY COUNT(a) DESC")
    List<Object[]> getUserActivityCount(@Param("start") LocalDateTime start, 
                                       @Param("end") LocalDateTime end);
    
    @Query("SELECT a.httpMethod, COUNT(a) FROM AuditLog a WHERE a.createdAt BETWEEN :start AND :end GROUP BY a.httpMethod")
    List<Object[]> getMethodCount(@Param("start") LocalDateTime start, 
                                 @Param("end") LocalDateTime end);
    
    @Query(value = "SELECT TO_CHAR(CREATED_AT, 'YYYY-MM-DD') as day, COUNT(*) as count " +
           "FROM AUDIT_LOGS WHERE CREATED_AT BETWEEN :start AND :end " +
           "GROUP BY TO_CHAR(CREATED_AT, 'YYYY-MM-DD') " +
           "ORDER BY day", nativeQuery = true)
    List<Object[]> getDailyCount(@Param("start") LocalDateTime start, 
                                @Param("end") LocalDateTime end);
}


package com.example.auditdemo.service;

import com.example.auditdemo.entity.AuditLog;
import com.example.auditdemo.repository.AuditLogRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.UnsupportedEncodingException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class AuditLogService {
    
    private final AuditLogRepository auditLogRepository;
    private final ObjectMapper objectMapper;
    private final HttpServletRequest httpServletRequest;
    
    // Oracle CLOB handling - avoid large objects
    private static final int MAX_BODY_SIZE = 4000; // Oracle VARCHAR2 max
    
    @Transactional
    public AuditLog save(AuditLog auditLog) {
        // Truncate large bodies for Oracle compatibility
        if (auditLog.getRequestBody() != null && auditLog.getRequestBody().length() > MAX_BODY_SIZE) {
            auditLog.setRequestBody(auditLog.getRequestBody().substring(0, MAX_BODY_SIZE) + "... [TRUNCATED]");
        }
        if (auditLog.getResponseBody() != null && auditLog.getResponseBody().length() > MAX_BODY_SIZE) {
            auditLog.setResponseBody(auditLog.getResponseBody().substring(0, MAX_BODY_SIZE) + "... [TRUNCATED]");
        }
        return auditLogRepository.save(auditLog);
    }
    
    @Async("auditTaskExecutor")
    @Transactional
    public CompletableFuture<AuditLog> saveAsync(AuditLog auditLog) {
        try {
            AuditLog saved = save(auditLog);
            return CompletableFuture.completedFuture(saved);
        } catch (Exception e) {
            log.error("Failed to save audit log asynchronously", e);
            return CompletableFuture.failedFuture(e);
        }
    }
    
    public AuditLog createAuditLog(HttpServletRequest request, 
                                  Object requestBody, 
                                  Object responseBody, 
                                  long executionTime, 
                                  Exception exception) {
        
        AuditLog auditLog = new AuditLog();
        
        // Get current user
        String username = getCurrentUsername();
        auditLog.setUsername(username != null ? username : "ANONYMOUS");
        
        // Set request details
        auditLog.setApiEndpoint(request.getRequestURI());
        auditLog.setHttpMethod(request.getMethod());
        auditLog.setClientIp(getClientIp(request));
        auditLog.setUserAgent(request.getHeader("User-Agent"));
        
        // Set request/response bodies with masking
        try {
            String reqBodyJson = requestBody != null ? 
                objectMapper.writeValueAsString(requestBody) : getRequestBodyAsString(request);
            
            String respBodyJson = responseBody != null ? 
                objectMapper.writeValueAsString(responseBody) : null;
            
            auditLog.setRequestBody(maskSensitiveData(reqBodyJson, request.getRequestURI()));
            
            if (respBodyJson != null) {
                auditLog.setResponseBody(maskSensitiveData(respBodyJson, request.getRequestURI()));
            }
        } catch (JsonProcessingException e) {
            log.warn("Failed to parse request/response for audit", e);
        }
        
        // Determine action type
        auditLog.setActionType(determineActionType(request.getMethod(), request.getRequestURI()));
        
        // Set status and error
        if (exception != null) {
            auditLog.setErrorMessage(truncate(exception.getMessage(), 4000));
            auditLog.setHttpStatus(500);
            auditLog.setIsSuccessful("N");
        } else {
            auditLog.setHttpStatus(200);
            auditLog.setIsSuccessful("Y");
        }
        
        // Set execution time
        auditLog.setExecutionTime(executionTime);
        
        // Additional metadata
        auditLog.setServiceName("oracle-backend-service");
        auditLog.setCorrelationId(getOrCreateCorrelationId(request));
        auditLog.setSessionId(request.getSession(false) != null ? 
                            request.getSession().getId() : null);
        
        // Extract resource ID from path (e.g., /api/users/123 -> 123)
        auditLog.setResourceId(extractResourceId(request.getRequestURI()));
        
        // Store headers (truncated for Oracle)
        auditLog.setRequestHeaders(truncate(getHeadersAsString(request), 4000));
        
        // Determine module
        auditLog.setModuleName(determineModule(request.getRequestURI()));
        
        return auditLog;
    }
    
    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated() && 
            !"anonymousUser".equals(authentication.getName())) {
            return authentication.getName();
        }
        return null;
    }
    
    private String getClientIp(HttpServletRequest request) {
        String[] headers = {"X-Forwarded-For", "Proxy-Client-IP", "WL-Proxy-Client-IP", 
                           "HTTP_X_FORWARDED_FOR", "HTTP_X_FORWARDED", 
                           "HTTP_X_CLUSTER_CLIENT_IP", "HTTP_CLIENT_IP", 
                           "HTTP_FORWARDED_FOR", "HTTP_FORWARDED", 
                           "HTTP_VIA", "REMOTE_ADDR"};
        
        for (String header : headers) {
            String ip = request.getHeader(header);
            if (StringUtils.isNotBlank(ip) && !"unknown".equalsIgnoreCase(ip)) {
                return ip.split(",")[0].trim();
            }
        }
        return request.getRemoteAddr();
    }
    
    private String getOrCreateCorrelationId(HttpServletRequest request) {
        String correlationId = request.getHeader("X-Correlation-ID");
        if (StringUtils.isBlank(correlationId)) {
            correlationId = request.getHeader("X-Request-ID");
        }
        if (StringUtils.isBlank(correlationId)) {
            correlationId = UUID.randomUUID().toString();
        }
        return correlationId;
    }
    
    private String getHeadersAsString(HttpServletRequest request) {
        Map<String, String> headers = new LinkedHashMap<>();
        Enumeration<String> headerNames = request.getHeaderNames();
        
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            // Skip sensitive headers
            if (!isSensitiveHeader(headerName)) {
                headers.put(headerName, request.getHeader(headerName));
            }
        }
        
        try {
            ObjectWriter writer = objectMapper.writerWithDefaultPrettyPrinter();
            return writer.writeValueAsString(headers);
        } catch (JsonProcessingException e) {
            return "{}";
        }
    }
    
    private boolean isSensitiveHeader(String headerName) {
        String lowerHeader = headerName.toLowerCase();
        return lowerHeader.contains("auth") || 
               lowerHeader.contains("token") || 
               lowerHeader.contains("password") || 
               lowerHeader.contains("secret") ||
               lowerHeader.contains("key");
    }
    
    private String maskSensitiveData(String json, String endpoint) {
        if (StringUtils.isBlank(json)) {
            return json;
        }
        
        try {
            // Mask passwords and tokens
            json = json.replaceAll("(?i)(\"password\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            json = json.replaceAll("(?i)(\"token\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            json = json.replaceAll("(?i)(\"accessToken\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            json = json.replaceAll("(?i)(\"refreshToken\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            json = json.replaceAll("(?i)(\"apiKey\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            json = json.replaceAll("(?i)(\"secret\"\\s*:\\s*\")[^\"]*(\")", "$1*****$2");
            
            // Mask emails
            json = json.replaceAll("(?i)(\"email\"\\s*:\\s*\")[^\"]*@[^\"]*(\")", "$1***@***$2");
            
            // Mask credit cards
            json = json.replaceAll("(?i)(\"creditCard\"\\s*:\\s*\")[^\"]*(\")", "$1****-****-****-****$2");
            json = json.replaceAll("(?i)(\"cardNumber\"\\s*:\\s*\")[^\"]*(\")", "$1****-****-****-****$2");
            
            // Mask SSN
            json = json.replaceAll("(?i)(\"ssn\"\\s*:\\s*\")[^\"]*(\")", "$1***-**-****$2");
            json = json.replaceAll("(?i)(\"socialSecurity\"\\s*:\\s*\")[^\"]*(\")", "$1***-**-****$2");
            
            return truncate(json, MAX_BODY_SIZE);
        } catch (Exception e) {
            log.warn("Failed to mask sensitive data", e);
            return truncate(json, MAX_BODY_SIZE);
        }
    }
    
    private String truncate(String text, int maxLength) {
        if (text == null || text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength - 50) + "... [TRUNCATED: " + text.length() + " chars]";
    }
    
    private String extractResourceId(String uri) {
        // Extract ID from URI patterns like /api/resources/{id}
        String[] parts = uri.split("/");
        if (parts.length >= 2) {
            try {
                // Try to parse the last part as a number
                Long.parseLong(parts[parts.length - 1]);
                return parts[parts.length - 1];
            } catch (NumberFormatException e) {
                // Not a number, return null
            }
        }
        return null;
    }
    
    private String determineActionType(String httpMethod, String endpoint) {
        if (StringUtils.containsIgnoreCase(endpoint, "create") || 
            StringUtils.containsIgnoreCase(endpoint, "add") ||
            StringUtils.containsIgnoreCase(endpoint, "register")) {
            return "CREATE";
        } else if (StringUtils.containsIgnoreCase(endpoint, "update") || 
                   StringUtils.containsIgnoreCase(endpoint, "modify") ||
                   StringUtils.containsIgnoreCase(endpoint, "edit")) {
            return "UPDATE";
        } else if (StringUtils.containsIgnoreCase(endpoint, "delete") || 
                   StringUtils.containsIgnoreCase(endpoint, "remove")) {
            return "DELETE";
        }
        
        // Default based on HTTP method
        return switch (httpMethod.toUpperCase()) {
            case "POST" -> "CREATE";
            case "PUT", "PATCH" -> "UPDATE";
            case "DELETE" -> "DELETE";
            default -> "READ";
        };
    }
    
    private String determineModule(String uri) {
        if (uri.contains("/api/users")) return "USER_MANAGEMENT";
        if (uri.contains("/api/products")) return "PRODUCT_MANAGEMENT";
        if (uri.contains("/api/orders")) return "ORDER_MANAGEMENT";
        if (uri.contains("/api/auth")) return "AUTHENTICATION";
        if (uri.contains("/api/reports")) return "REPORTING";
        if (uri.contains("/api/audit")) return "AUDIT";
        return "OTHER";
    }
    
    private String getRequestBodyAsString(HttpServletRequest request) {
        if (request instanceof ContentCachingRequestWrapper) {
            return getRequestBodyFromCache((ContentCachingRequestWrapper) request);
        }
        return null;
    }
    
    public String getRequestBodyFromCache(ContentCachingRequestWrapper request) {
        try {
            byte[] buf = request.getContentAsByteArray();
            if (buf.length > 0) {
                return new String(buf, request.getCharacterEncoding());
            }
        } catch (UnsupportedEncodingException e) {
            log.error("Failed to read cached request body", e);
        }
        return null;
    }
    
    public String getResponseBodyFromCache(ContentCachingResponseWrapper response) {
        try {
            byte[] buf = response.getContentAsByteArray();
            if (buf.length > 0) {
                return new String(buf, response.getCharacterEncoding());
            }
        } catch (UnsupportedEncodingException e) {
            log.error("Failed to read cached response body", e);
        }
        return null;
    }
    
    // Statistics methods
    public Map<String, Object> getAuditStatistics(LocalDateTime startDate, LocalDateTime endDate) {
        Map<String, Object> stats = new LinkedHashMap<>();
        
        if (startDate == null) startDate = LocalDateTime.now().minusDays(30);
        if (endDate == null) endDate = LocalDateTime.now();
        
        Long totalRequests = auditLogRepository.countSince(startDate);
        List<Object[]> statusCounts = auditLogRepository.getStatusCount(startDate, endDate);
        List<Object[]> userActivity = auditLogRepository.getUserActivityCount(startDate, endDate);
        List<Object[]> methodCounts = auditLogRepository.getMethodCount(startDate, endDate);
        List<Object[]> dailyCounts = auditLogRepository.getDailyCount(startDate, endDate);
        
        stats.put("period", Map.of("start", startDate, "end", endDate));
        stats.put("totalRequests", totalRequests);
        stats.put("statusDistribution", convertToMap(statusCounts));
        stats.put("topUsers", convertToMap(userActivity.stream().limit(10).toList()));
        stats.put("methodDistribution", convertToMap(methodCounts));
        stats.put("dailyActivity", convertToMap(dailyCounts));
        
        return stats;
    }
    
    private Map<String, Object> convertToMap(List<Object[]> data) {
        Map<String, Object> map = new LinkedHashMap<>();
        for (Object[] row : data) {
            if (row.length >= 2) {
                map.put(row[0].toString(), row[1]);
            }
        }
        return map;
    }
    
    // Pagination methods
    public Page<AuditLog> getAllAuditLogs(Pageable pageable) {
        return auditLogRepository.findAll(pageable);
    }
    
    public Page<AuditLog> searchAuditLogs(String username, String endpoint, 
                                         String method, Integer status, String success,
                                         LocalDateTime startDate, LocalDateTime endDate,
                                         Pageable pageable) {
        if (startDate == null) startDate = LocalDateTime.now().minusDays(7);
        if (endDate == null) endDate = LocalDateTime.now().plusDays(1);
        
        return auditLogRepository.searchAuditLogs(username, endpoint, method, status, 
                                                 success, startDate, endDate, pageable);
    }
    
    public Optional<AuditLog> getAuditLogById(Long id) {
        return auditLogRepository.findById(id);
    }
    
    @Transactional
    public void deleteAuditLog(Long id) {
        auditLogRepository.deleteById(id);
    }
    
    public Page<AuditLog> getAuditLogsByUsername(String username, Pageable pageable) {
        return auditLogRepository.findByUsername(username, pageable);
    }
    
    // Archive old logs (Oracle-specific)
    @Async
    @Transactional
    public CompletableFuture<Integer> archiveOldLogs(int daysToKeep) {
        try {
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(daysToKeep);
            
            // Create archive table if not exists (Oracle syntax)
            // This is a simplified version - in production, you'd use proper DDL
            
            // Archive logs older than cutoff
            List<AuditLog> oldLogs = auditLogRepository.findByCreatedAtBetween(
                LocalDateTime.MIN, cutoffDate, Pageable.unpaged()).getContent();
            
            log.info("Archiving {} old audit logs", oldLogs.size());
            
            // Here you would move to archive table, for now just delete
            // In production: implement proper archiving strategy
            auditLogRepository.deleteAll(oldLogs);
            
            return CompletableFuture.completedFuture(oldLogs.size());
        } catch (Exception e) {
            log.error("Failed to archive old logs", e);
            return CompletableFuture.failedFuture(e);
        }
    }
}


-- Create tablespace (if needed)
CREATE TABLESPACE AUDIT_TS 
DATAFILE 'audit_ts.dbf' 
SIZE 100M 
AUTOEXTEND ON 
NEXT 10M 
MAXSIZE UNLIMITED;

-- Create user
CREATE USER AUDIT_USER IDENTIFIED BY AuditPass123
DEFAULT TABLESPACE AUDIT_TS
TEMPORARY TABLESPACE TEMP
QUOTA UNLIMITED ON AUDIT_TS;

-- Grant privileges
GRANT CONNECT, RESOURCE TO AUDIT_USER;
GRANT CREATE SESSION TO AUDIT_USER;
GRANT CREATE TABLE TO AUDIT_USER;
GRANT CREATE SEQUENCE TO AUDIT_USER;
GRANT CREATE VIEW TO AUDIT_USER;

-- Create sequence
CREATE SEQUENCE AUDIT_USER.AUDIT_LOG_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

-- Create audit logs table
CREATE TABLE AUDIT_USER.AUDIT_LOGS (
    ID NUMBER(19) PRIMARY KEY,
    USERNAME VARCHAR2(255) NOT NULL,
    API_ENDPOINT VARCHAR2(1000) NOT NULL,
    HTTP_METHOD VARCHAR2(10) NOT NULL,
    REQUEST_BODY CLOB,
    RESPONSE_BODY CLOB,
    HTTP_STATUS NUMBER(10) NOT NULL,
    CLIENT_IP VARCHAR2(45),
    USER_AGENT VARCHAR2(1000),
    EXECUTION_TIME NUMBER(19),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ERROR_MESSAGE VARCHAR2(4000),
    SERVICE_NAME VARCHAR2(100),
    CORRELATION_ID VARCHAR2(100),
    SESSION_ID VARCHAR2(100),
    REQUEST_HEADERS CLOB,
    RESOURCE_ID VARCHAR2(100),
    ACTION_TYPE VARCHAR2(50),
    IS_SUCCESSFUL VARCHAR2(1) DEFAULT 'Y',
    MODULE_NAME VARCHAR2(100)
);

-- Create indexes for performance
CREATE INDEX IDX_AUDIT_LOGS_USERNAME ON AUDIT_USER.AUDIT_LOGS(USERNAME);
CREATE INDEX IDX_AUDIT_LOGS_CREATED_AT ON AUDIT_USER.AUDIT_LOGS(CREATED_AT);
CREATE INDEX IDX_AUDIT_LOGS_ENDPOINT ON AUDIT_USER.AUDIT_LOGS(API_ENDPOINT);
CREATE INDEX IDX_AUDIT_LOGS_STATUS ON AUDIT_USER.AUDIT_LOGS(
