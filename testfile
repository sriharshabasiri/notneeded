#!/usr/bin/env python3
"""
generate_passwords.py
Generates passwords for a list of DB users, outputs:
 - passwords.txt (username=plainpassword)
 - alter_users.sql (ALTER USER ... IDENTIFIED BY 'password';)
 - passwords.json (JSON mapping)
"""

import secrets
import string
import json

USERS = [
    "corebank_read","corebank_supt","dfscust","crmuser","fimaster",
    "ssoadm","fiejb","intadm","ceadm","apdmrhel","dedupadm","finbatchperf"
]

def make_password(length=12):
    # Ensure required char sets: digit, underscore, upper, lower
    alphabet_lower = string.ascii_lowercase
    alphabet_upper = string.ascii_uppercase
    digits = string.digits
    special = "_"  # required special char
    # pick one from each required bucket
    parts = [
        secrets.choice(alphabet_lower),
        secrets.choice(alphabet_upper),
        secrets.choice(digits),
        special
    ]
    # fill the rest with allowed chars
    pool = alphabet_lower + alphabet_upper + digits + special
    while len(parts) < length:
        parts.append(secrets.choice(pool))
    # shuffle securely
    secrets.SystemRandom().shuffle(parts)
    return ''.join(parts)

def main():
    mapping = {}
    with open("passwords.txt", "w") as f_txt, open("alter_users.sql", "w") as f_sql:
        f_sql.write("-- generated by generate_passwords.py\n")
        for u in USERS:
            pwd = make_password(12)
            mapping[u] = pwd
            f_txt.write(f"{u}={pwd}\n")
            # SQL: wrap password in double quotes if needed (Oracle rules). Using single quotes here.
            f_sql.write(f"ALTER USER {u} IDENTIFIED BY \"{pwd}\";\n")
    with open("passwords.json", "w") as f_json:
        json.dump(mapping, f_json, indent=2)
    print("Generated passwords.txt, alter_users.sql, passwords.json")

if __name__ == "__main__":
    main()



[db_servers]
dbhost1.example.com ansible_user=oracleadmin env=dev1
dbhost2.example.com ansible_user=oracleadmin env=dev2
# add all DB hosts (or a bastion that can run sqlplus)

[jboss_servers]
jboss1.dev1.example.com ansible_user=jbossadmin env=dev1
jboss2.dev1.example.com ansible_user=jbossadmin env=dev1
# add all JBoss hosts per env

[all:vars]
ansible_python_interpreter=/usr/bin/python3


---
- name: Generate passwords locally (control node) if not already present
  hosts: localhost
  gather_facts: no
  vars:
    password_gen_script: ./generate_passwords.py
  tasks:
    - name: Ensure Python generator exists
      stat:
        path: "{{ password_gen_script }}"
      register: gen_exists

    - name: Run password generator if outputs do not exist
      command: "{{ password_gen_script }}"
      when: gen_exists.stat.exists and not (lookup('file', 'passwords.json', errors='ignore') | default('') != '')
      register: gen_result
      changed_when: gen_result.rc == 0

    - name: Fail if passwords.json not found after generator
      fail:
        msg: "passwords.json not found. Please ensure generate_passwords.py produced it."
      when: lookup('file', 'passwords.json', errors='ignore') | default('') == ''

    - name: Read passwords.json into variable
      set_fact:
        pw_map: "{{ lookup('file','passwords.json') | from_json }}"

    - name: Write a consolidated txt for artifacts (on control)
      copy:
        dest: "./artifacts/passwords_{{ ansible_date_time.date }}.txt"
        content: |
          {% for k,v in pw_map.items() -%}
          {{ k }}={{ v }}
          {% endfor %}
      delegate_to: localhost

- name: Apply new passwords to Oracle and propagate to JBoss
  hosts: db_servers:jboss_servers
  gather_facts: yes
  vars:
    # Oracle connection details - set in Vault or inventory or as vars_prompt
    oracle_user: "{{ lookup('env','ORACLE_ADMIN_USER') | default('sys as sysdba') }}"
    oracle_pass: "{{ lookup('env','ORACLE_ADMIN_PASS') | default('changeme') }}"
    oracle_connect_string: "{{ lookup('env','ORACLE_CONNECT') | default('ORCLPDB1') }}"  # tns alias or host:port/service
    # JBOSS specifics (customize)
    JBOSS_HOME: "/opt/jboss/v7.0"
    standalone_xml_path: "{{ JBOSS_HOME }}/standalone/configuration/standalone-full-ha.xml"
    backup_suffix: "PPM_{{ ansible_date_time.date }}"
    # users list (should match generator)
    db_users_list:
      - corebank_read
      - corebank_supt
      - dfscust
      - crmuser
      - fimaster
      - ssoadm
      - fiejb
      - intadm
      - ceadm
      - apdmrhel
      - dedupadm
      - finbatchperf

  tasks:
    - name: Load passwords.json from control node to a variable
      slurp:
        src: "{{ playbook_dir }}/passwords.json"
      delegate_to: localhost
      run_once: true
      register: pw_json_slurp

    - name: Set password map fact
      set_fact:
        pw_map: "{{ pw_json_slurp.content | b64decode | from_json }}"
      run_once: true

    - name: Apply ALTER USER SQL on DB hosts (push SQL and run via sqlplus)
      when: "'db_servers' in group_names"
      block:
        - name: Create alter_users.sql on DB host
          copy:
            dest: /tmp/alter_users_{{ inventory_hostname }}.sql
            content: |
              SET ECHO ON
              SET FEEDBACK ON
              SET HEADING OFF
              WHENEVER SQLERROR EXIT FAILURE
              {% for u,p in pw_map.items() %}
              ALTER USER {{ u }} IDENTIFIED BY "{{ p }}";
              {% endfor %}
              COMMIT;
          mode: '0600'

        - name: Run alter script via sqlplus (assumes sqlplus in PATH and proper env)
          shell: |
            export ORACLE_SID={{ oracle_connect_string | quote }}
            echo "Running sqlplus - connecting as {{ oracle_user }}"
            echo exit | sqlplus -s {{ oracle_user }}/{{ oracle_pass }}@{{ oracle_connect_string }} @/tmp/alter_users_{{ inventory_hostname }}.sql
          args:
            warn: false
          register: sql_result
          failed_when: sql_result.rc != 0

        - name: Save the plain passwords file on DB host (owner only)
          copy:
            dest: "/tmp/clear_passwords_{{ inventory_hostname }}.txt"
            content: |
              {% for k,v in pw_map.items() -%}
              {{ k }}={{ v }}
              {% endfor %}
          mode: '0600'

    - name: Update JBoss configs with encoded passwords and restart JBoss
      when: "'jboss_servers' in group_names"
      block:
        - name: Backup standalone-full-ha.xml
          shell: |
            mkdir -p {{ JBOSS_HOME }}/standalone/configuration/backup || true
            cp -p "{{ standalone_xml_path }}" "{{ standalone_xml_path }}_{{ backup_suffix }}"
            cp -p "{{ standalone_xml_path }}" "{{ JBOSS_HOME }}/standalone/configuration/backup/standalone-full-ha.xml_{{ backup_suffix }}"
          args:
            executable: /bin/bash

        - name: Ensure we have the plain password mapping on JBoss host (create temp file)
          copy:
            dest: "/tmp/passwords_for_{{ inventory_hostname }}.txt"
            content: |
              {% for k,v in pw_map.items() -%}
              {{ k }}={{ v }}
              {% endfor %}
          mode: '0600'

        - name: For each user: run Java encoder and collect encoded password
          vars:
            encoder_class: "org.picketbox.datasource.security.SecureIdentityLoginModule"
            java_cp: "{{ JBOSS_HOME }}/modules/system/layers/base/org/picketbox/main/*:{{ JBOSS_HOME }}/modules/system/layers/base/org/jboss/logging/main/*"
          shell: |
            set -euo pipefail
            USER="{{ item.key }}"
            PLAIN="{{ item.value }}"
            # run java to produce encoded password (depends on jboss module class availability)
            export CLASSPATH={{ java_cp }}
            # invoke the encoder and print USER|ENCODED
            encoded=$(java {{ encoder_class }} "$PLAIN" 2>/dev/null || true)
            if [ -z "$encoded" ]; then
              echo "ERROR_ENCODING::$USER"
              exit 10
            fi
            echo "$USER|$encoded"
          args:
            executable: /bin/bash
          loop: "{{ pw_map | dict2items }}"
          register: encoder_results
          failed_when: encoder_results.results | selectattr('rc','ne',0) | list | length > 0

        - name: Build a mapping file of encoded passwords
          copy:
            dest: "/tmp/encoded_passwords_{{ inventory_hostname }}.txt"
            content: |
              {% for r in encoder_results.results %}
              {{ r.stdout }}
              {% endfor %}
          mode: '0600'

        - name: Update standalone-full-ha.xml passwords (one replace per user)
          vars:
            xml_file: "{{ standalone_xml_path }}"
          block:
            - name: Read encoded mapping into a list
              slurp:
                src: "/tmp/encoded_passwords_{{ inventory_hostname }}.txt"
              register: encoded_slurp

            - name: Set encoded_map fact
              set_fact:
                encoded_map_lines: "{{ (encoded_slurp.content | b64decode).splitlines() }}"

            - name: Replace password values in standalone xml for each user
              vars:
                user_name: "{{ item.split('|')[0] }}"
                enc_value: "{{ item.split('|')[1] }}"
                # regex looks for module-option name="password" value="..."/> following the username's module-option (approx)
                # We'll perform a safer two-step: ensure the username exists, then replace the next password attribute
                # Use python oneliner to do safe xml replacement (keeps formatting)
              block:
                - name: Ensure username exists in xml (debug)
                  shell: |
                    grep -A2 '<module-option name="username" value="{{ user_name }}"' "{{ xml_file }}" || true
                  register: grep_user
                  failed_when: false

                - name: Replace the password value for {{ user_name }} using python script
                  shell: |
                    python3 - <<'PY'
import sys, re
fn = "{{ xml_file }}"
user="{{ user_name }}"
enc="{{ enc_value }}"
with open(fn, 'r', encoding='utf-8') as f:
    s = f.read()
# pattern: find the username line, then replace password value attribute in the following lines
pattern = re.compile(r'(<module-option\s+name="username"\s+value="%s"\s*/?>\\s*)(.*?)((<module-option\s+name="password"\s+value=")([^"]*)(".*?/?>))' % re.escape(user), re.S)
m = pattern.search(s)
if m:
    before = m.group(1)
    middle = m.group(2)
    # build replacement for the password module-option
    new_pass_line = m.group(3).replace(m.group(5), enc)
    new = pattern.sub(before + middle + new_pass_line, s, count=1)
    with open(fn, 'w', encoding='utf-8') as fw:
        fw.write(new)
    print("UPDATED")
else:
    # fallback: replace any password attribute that comes after username instance (more tolerant)
    # naive replace of the next occurrence of <module-option name="password" ...
    lines = s.splitlines()
    out=[]
    i=0
    updated=False
    while i < len(lines):
        out.append(lines[i])
        if ('<module-option' in lines[i]) and ('name="username"' in lines[i]) and ('value="%s"' % user in lines[i]):
            # scan ahead for password line
            j=i+1
            while j < len(lines) and not ('name="password"' in lines[j]):
                out.append(lines[j])
                j+=1
            if j < len(lines) and 'name="password"' in lines[j]:
                # replace password value
                out.append(re.sub(r'value="[^"]*"', 'value="%s"' % enc, lines[j]))
                updated=True
                i=j+1
                continue
        i+=1
    if updated:
        with open(fn, 'w', encoding='utf-8') as fw:
            fw.write("\n".join(out))
        print("UPDATED_FALLBACK")
    else:
        print("NOT_FOUND")
PY
                  args:
                    executable: /bin/bash
              loop: "{{ encoded_map_lines }}"

        - name: Restart JBoss: stop then start using aliases
          shell: |
            set -e
            # try alias or script
            if command -v stopjboss >/dev/null 2>&1; then
              stopjboss || true
            else
              # fallback: try systemctl or run as jboss admin script (customize if needed)
              echo "stopjboss alias not found; you may need to update this step to your environment"
            fi
            sleep 2
            if command -v startjboss >/dev/null 2>&1; then
              startjboss || true
            else
              echo "startjboss alias not found; please adjust"
            fi
          args:
            executable: /bin/bash





all:
  vars:
    ansible_python_interpreter: /usr/bin/python3
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'

  children:
    dev:
      children:
        dev1:
          hosts:
            db-dev1:
              ansible_host: db-dev1.example.com
              env: dev1
            jboss-dev1:
              ansible_host: jboss-dev1.example.com
              env: dev1
        dev2:
          hosts:
            db-dev2:
              ansible_host: db-dev2.example.com
              env: dev2
            jboss-dev2:
              ansible_host: jboss-dev2.example.com
              env: dev2
        # Add similarly up to dev10...

    dm:
      children:
        dm1:
          hosts:
            db-dm1:
              ansible_host: db-dm1.example.com
              env: dm1
            jboss-dm1:
              ansible_host: jboss-dm1.example.com
              env: dm1
        dm2:
          hosts:
            db-dm2:
              ansible_host: db-dm2.example.com
              env: dm2
            jboss-dm2:
              ansible_host: jboss-dm2.example.com
              env: dm2

    perf:
      children:
        perf1:
          hosts:
            db-perf1:
              ansible_host: db-perf1.example.com
              env: perf1
            jboss-perf1:
              ansible_host: jboss-perf1.example.com
              env: perf1
        perf2:
          hosts:
            db-perf2:
              ansible_host: db-perf2.example.com
              env: perf2
            jboss-perf2:
              ansible_host: jboss-perf2.example.com
              env: perf2

    esqm:
      children:
        asys:
          hosts:
            db-asys:
              ansible_host: db-asys.example.com
              env: asys
            jboss-asys:
              ansible_host: jboss-asys.example.com
              env: asys
        tsys:
          hosts:
            db-tsys:
              ansible_host: db-tsys.example.com
              env: tsys
            jboss-tsys:
              ansible_host: jboss-tsys.example.com
              env: tsys
        msto:
          hosts:
            db-msto:
              ansible_host: db-msto.example.com
              env: msto
            jboss-msto:
              ansible_host: jboss-msto.example.com
              env: msto
        vsto:
          hosts:
            db-vsto:
              ansible_host: db-vsto.example.com
              env: vsto
            jboss-vsto:
              ansible_host: jboss-vsto.example.com
              env: vsto
        qsys:
          hosts:
            db-qsys:
              ansible_host: db-qsys.example.com
              env: qsys
            jboss-qsys:
              ansible_host: jboss-qsys.example.com
              env: qsys

    # Logical groupings (used by playbook)
    db_servers:
      hosts:
        db-dev1:
        db-dev2:
        db-dm1:
        db-dm2:
        db-perf1:
        db-perf2:
        db-asys:
        db-tsys:
        db-msto:
        db-vsto:
        db-qsys:
        # Add db-dev3..db-dev10 if applicable

    jboss_servers:
      hosts:
        jboss-dev1:
        jboss-dev2:
        jboss-dm1:
        jboss-dm2:
        jboss-perf1:
        jboss-perf2:
        jboss-asys:
        jboss-tsys:
        jboss-msto:
        jboss-vsto:
        jboss-qsys:
        # Add jboss-dev3..jboss-dev10 if applicable
